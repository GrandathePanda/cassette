{"version":3,"sources":["webpack://cassetteCore/webpack/universalModuleDefinition","webpack://cassetteCore/webpack/bootstrap","webpack://cassetteCore/external {\"root\":\"PropTypes\",\"commonjs\":\"prop-types\",\"commonjs2\":\"prop-types\",\"amd\":\"prop-types\"}","webpack://cassetteCore/external {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\"}","webpack://cassetteCore/./node_modules/array-find-index/index.js","webpack://cassetteCore/./src/PlayerContext.js","webpack://cassetteCore/./src/GroupContext.js","webpack://cassetteCore/./src/constants.js","webpack://cassetteCore/./src/utils/console.js","webpack://cassetteCore/./src/PlayerPropTypes.js","webpack://cassetteCore/./src/factories/createCustomMediaElement.js","webpack://cassetteCore/./src/utils/ShuffleManager.js","webpack://cassetteCore/./src/utils/isPlaylistValid.js","webpack://cassetteCore/./src/utils/getTrackSources.js","webpack://cassetteCore/./src/utils/findTrackIndexByUrl.js","webpack://cassetteCore/./src/utils/getSourceList.js","webpack://cassetteCore/./src/utils/getTimeRangesArray.js","webpack://cassetteCore/./src/utils/getRepeatStrategy.js","webpack://cassetteCore/./src/utils/convertToNumberWithinIntervalBounds.js","webpack://cassetteCore/./src/utils/streamVideoElementToCanvas.js","webpack://cassetteCore/./src/PlayerContextProvider.js","webpack://cassetteCore/./src/utils/snapshot.js","webpack://cassetteCore/./src/PlayerContextGroup.js","webpack://cassetteCore/./src/FullscreenContext.js","webpack://cassetteCore/./src/FullscreenContextProvider.js","webpack://cassetteCore/./src/playerContextFilter.js","webpack://cassetteCore/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","arr","predicate","ctx","Array","findIndex","TypeError","list","len","length","PlayerContext","external_root_React_commonjs_react_commonjs2_react_amd_react_","displayName","src_PlayerContext","GroupContext","src_GroupContext","repeatStrategyOptions","log","console","logError","error","logWarning","warn","requiredOnlyUnlessHasProp","propType","altPropName","warnedAboutDefiningBoth","props","propName","componentName","_len","arguments","rest","_key","isRequired","apply","concat","Error","controlKeyword","external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default","a","oneOf","control","oneOfType","func","crossOriginAttribute","PlayerPropTypes_repeatStrategy","mediaSource","shape","src","string","type","mediaSessionAction","mediaSessionArtwork","sizes","PlayerPropTypes_track","url","sources","arrayOf","title","artist","album","artwork","meta","progressDirection","seekMode","aspectRatio","prop","undefined","split","some","isNaN","loopchange","srcrequest","factories_createCustomMediaElement","media","document","createElement","MutationObserver","dispatchEvent","Event","observe","attributeFilter","currentSrc","set","e","srcRequested","_goForward","forwardStack","backStack","currentItem","item","push","pop","_findNextItem","allowMore","indexOf","_allItemsMatch","nextItem","Math","floor","random","utils_ShuffleManager","ShuffleManager","options","this","_list","_forwardStack","_backStack","_currentItem","_allowBackShuffle","Boolean","allowBackShuffle","_proto","findNextItem","currentIndex","setCurrentIndex","findPreviousItem","pickNextItem","index","setList","setOptions","_arr","keys","_i","clear","utils_isPlaylistValid","playlist","blankSources","utils_getTrackSources","_playlist$index","utils_findTrackIndexByUrl","array_find_index_default","track","source","utils_getSourceList","map","_","utils_getTimeRangesArray","timeRangesObj","timeRangesArray","start","end","utils_getRepeatStrategy","loop","cycle","utils_convertToNumberWithinIntervalBounds","number","min","max","Infinity","utils_streamVideoElementToCanvas","videoElement","canvas","callback","getContext","requestId","widthSet","heightSet","placeholderImage","requestAnimationFrame","streamToCanvas","videoWidth","videoHeight","imageElement","imageWidth","imageHeight","targetWidth","targetHeight","isVideo","naturalWidth","naturalHeight","width","height","drawImage","endStream","cancelAnimationFrame","setCanvasSize","setPlaceholderImage","img","playErrorHandler","err","warningMessage","Date","toLocaleTimeString","supportableMediaSessionActions","defaultState","paused","currentTime","seekPreviewTime","seekInProgress","awaitingResumeOnSeekComplete","duration","bufferedRanges","playedRanges","seekableRanges","stalled","awaitingPlay","getGoToTrackState","prevState","shouldPlay","isNewTrack","activeTrackIndex","trackLoading","PlayerContextProvider_PlayerContextProvider","_Component","PlayerContextProvider","_this","state","_objectSpread","startingTrackIndex","startingTime","volume","defaultVolume","muted","defaultMuted","defaultRepeatStrategy","shuffle","defaultShuffle","playbackRate","defaultPlaybackRate","setVolumeInProgress","autoplay","__playlist__","initialStateSnapshot","snapshot","_snapshot$__unstable_","__unstable__","activeTrackSrc","restoredStateValues","useCurrentTime","newTrackIndex","restoreStateFromSnapshot","lastStableVolume","shuffler","setMediaElementRef","_assertThisInitialized","togglePause","selectTrackIndex","forwardSkip","backSkip","seekPreview","seekComplete","setVolume","setVolumeComplete","toggleMuted","toggleShuffle","setRepeatStrategy","setPlaybackRate","pipeVideoStreamToCanvas","handleMediaPlay","handleMediaPause","handleMediaSrcrequest","handleMediaEnded","handleMediaStalled","handleMediaCanplaythrough","handleMediaTimeupdate","handleMediaLoadedmetadata","handleMediaVolumechange","handleMediaDurationchange","handleMediaProgress","handleMediaLoopchange","handleMediaRatechange","_inheritsLoose","componentDidMount","_this2","readyState","addEventListener","setState","delayTimeout","setTimeout","autoplayDelayInSeconds","getDerivedStateFromProps","nextProps","newPlaylist","baseNewState","prevSources","currentSources","componentDidUpdate","prevProps","_this3","newSources","load","stealMediaSession","clearTimeout","snapshotUpdateTimeout","onStateSnapshot","getStateSnapshot","componentWillUnmount","removeEventListener","gapLengthTimeout","ref","mediaElementRef","_this4","MediaSession","navigator","mediaSession","metadata","MediaMetadata","action","supportedMediaSessionActions","seekLength","mediaSessionSeekLengthInSeconds","forEach","handler","setActionHandler","_props","loadFirstTrackOnPlaylistComplete","_state","goToTrack","gapLengthInSeconds","_media","played","_media2","buffered","seekable","pause","playPromise","play","catch","Promise","reject","_props2","stayOnBackSkipThreshold","_state2","previousItem","_state3","targetTime","baseStateUpdate","_ref","_ref2","ended","_state4","volumeInBounds","repeatStrategy","rate","getControlProps","playerContext","onTogglePause","onSelectTrackIndex","onBackSkip","onForwardSkip","onSeekPreview","onSeekComplete","onSetVolume","onSetVolumeComplete","onToggleMuted","onToggleShuffle","onSetRepeatStrategy","onSetPlaybackRate","render","external_root_React_commonjs_react_commonjs2_react_amd_react_default","hidden","crossOrigin","preload","onPlay","onPause","onEnded","onStalled","onCanPlayThrough","onTimeUpdate","onLoadedMetadata","onVolumeChange","onDurationChange","onProgress","onRateChange","Provider","children","propTypes","bool","maintainPlaybackRate","node","defaultProps","PlayerContextProvider_PlayerContextGroupMember","_Component2","PlayerContextGroupMember","_proto2","groupContext","registerMediaElement","mediaElement","unregisterMediaElement","_this5","_props3","_objectWithoutProperties","_extends","groupProps","src_PlayerContextProvider","Consumer","PlayerContextGroup_PlayerContextGroup","PlayerContextGroup","PlayerContextGroup_assertThisInitialized","enforceOneMediaSourceOnly","mediaElements","PlayerContextGroup_inheritsLoose","elem","filter","element","target","_iterator","_isArray","isArray","iterator","next","done","PlayerContextGroup_objectSpread","src_PlayerContextGroup","FullscreenContext","fullscreen","requestFullscreen","requestExitFullscreen","src_FullscreenContext","fullscreenStyle","FullscreenContextProvider_FullscreenContextProvider","_PureComponent","FullscreenContextProvider","FullscreenContextProvider_assertThisInitialized","handleFullscreenChange","fullscreenElement","FullscreenContextProvider_inheritsLoose","fullscreenEnabled","webkitRequestFullscreen","mozRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","webkitCancelFullScreen","mozCancelFullScreen","msExitFullscreen","mozExitFullscreen","documentFullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","getFullscreenContext","fullscreenContext","style","src_FullscreenContextProvider","src_playerContextFilter","component","contextPropNames","warned","childName","PlayerContextFilter","childProps","playerContextFilter_objectSpread","PlayerContextConsumer","FullscreenContextConsumer"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,EAAAG,QAAA,cAAAA,QAAA,UACA,mBAAAC,eAAAC,IACAD,QAAA,sBAAAJ,GACA,iBAAAC,QACAA,QAAA,aAAAD,EAAAG,QAAA,cAAAA,QAAA,UAEAJ,EAAA,aAAAC,EAAAD,EAAA,UAAAA,EAAA,OARA,CASCO,OAAA,SAAAC,EAAAC,GACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAV,QAGA,IAAAC,EAAAO,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAZ,YAUA,OANAa,EAAAH,GAAAI,KAAAb,EAAAD,QAAAC,IAAAD,QAAAS,GAGAR,EAAAW,GAAA,EAGAX,EAAAD,QA0DA,OArDAS,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAjB,EAAAkB,EAAAC,GACAV,EAAAW,EAAApB,EAAAkB,IACAG,OAAAC,eAAAtB,EAAAkB,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAzB,GACA,oBAAA0B,eAAAC,aACAN,OAAAC,eAAAtB,EAAA0B,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAtB,EAAA,cAAiD4B,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAnC,GACA,IAAAkB,EAAAlB,KAAA8B,WACA,WAA2B,OAAA9B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAQ,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,QAIAhC,IAAAiC,EAAA,mBClFAzC,EAAAD,QAAAM,iBCAAL,EAAAD,QAAAO,gCCCAN,EAAAD,QAAA,SAAA2C,EAAAC,EAAAC,GACA,sBAAAC,MAAAP,UAAAQ,UACA,OAAAJ,EAAAI,UAAAH,EAAAC,GAGA,sBAAAD,EACA,UAAAI,UAAA,gCAGA,IAAAC,EAAA5B,OAAAsB,GACAO,EAAAD,EAAAE,OAEA,OAAAD,EACA,SAGA,QAAAvC,EAAA,EAAgBA,EAAAuC,EAASvC,IACzB,GAAAiC,EAAA9B,KAAA+B,EAAAI,EAAAtC,KAAAsC,GACA,OAAAtC,EAIA,wlBCrBMyC,EAAgB/B,OAAAgC,EAAA,cAAAhC,CAAc,MACpC+B,EAAcE,YAAc,gBAE5B,IAAAC,EAAA,ECHMC,EAAenC,OAAAgC,EAAA,cAAAhC,CAAc,MACnCmC,EAAaF,YAAc,eAE3B,IAAAG,EAAA,ECLaC,GAAyB,OAAQ,WAAY,SCEpDC,EAAMC,QAAQD,IAAIxB,KAAKyB,SAEhBC,EAAWD,QAAQE,MAAQF,QAAQE,MAAM3B,KAAKyB,SAAWD,EACzDI,EAAaH,QAAQI,KAAOJ,QAAQI,KAAK7B,KAAKyB,SAAWD,ECAtE,SAASM,EAA0BC,EAAUC,GAC3C,IAAIC,GAA0B,EAiB9B,OAhBA,SAAkBC,EAAOC,EAAUC,GACjC,GAAID,KAAYD,EAAO,EAChBD,GAA2BD,KAAeE,IAC7CN,6BAC6BO,EAD7B,UAC+CH,EAD/C,YAGAC,GAA0B,GALP,QAAAI,EAAAC,UAAAtB,OAD4BuB,EAC5B,IAAA5B,MAAA0B,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAD4BD,EAC5BC,EAAA,GAAAF,UAAAE,GAOrB,OAAOT,EAASU,WAATC,MAAAX,GAAoBG,EAAOC,EAAUC,GAArCO,OAAuDJ,IAEhE,KAAMP,KAAeE,GACnB,OAAO,IAAIU,MAAJ,WACMZ,EADN,2BAC4CG,EAD5C,eAQN,IAAMU,EAAiBC,EAAAC,EAAUC,OACtC,YACA,WACA,cACA,SACA,OACA,SACA,UACA,WACA,kBACA,aACA,WAGWC,EAAUH,EAAAC,EAAUG,WAAWJ,EAAAC,EAAUI,KAAMN,IAE/CO,EAAuBN,EAAAC,EAAUC,OAC5C,YACA,oBAGWK,EAAiBP,EAAAC,EAAUC,MAAMzB,GAEjC+B,EAAcR,EAAAC,EAAUQ,OACnCC,IAAKV,EAAAC,EAAUU,OAAOhB,WACtBiB,KAAMZ,EAAAC,EAAUU,OAAOhB,aAGZkB,EAAqBb,EAAAC,EAAUC,OAC1C,OACA,QACA,gBACA,YACA,eACA,gBAGWY,EAAsBd,EAAAC,EAAUQ,OAC3CC,IAAKV,EAAAC,EAAUU,OAAOhB,WACtBoB,MAAOf,EAAAC,EAAUU,OACjBC,KAAMZ,EAAAC,EAAUU,SAGLK,EAAQhB,EAAAC,EAAUQ,OAC7BQ,IAAKjC,EAA0BgB,EAAAC,EAAUU,OAAQ,WACjDO,QAASlC,EACPgB,EAAAC,EAAUkB,QAAQX,EAAYb,YAC9B,OAEFyB,MAAOpB,EAAAC,EAAUU,OAAOhB,WACxB0B,OAAQrB,EAAAC,EAAUU,OAClBW,MAAOtB,EAAAC,EAAUU,OACjBY,QAASvB,EAAAC,EAAUkB,QAAQL,EAAoBnB,YAC/C6B,KAAMxB,EAAAC,EAAU7C,SAGLqE,EAAoBzB,EAAAC,EAAUC,OACzC,OACA,QACA,KACA,SAGWwB,EAAW1B,EAAAC,EAAUC,OAAO,SAAU,YAAa,cAEzD,SAASyB,EAAYvC,EAAOC,GACjC,IAAMuC,EAAOxC,EAAMC,GACnB,QAAawC,IAATD,EAGJ,MACkB,iBAATA,GACoB,IAA3BA,EAAKE,MAAM,KAAK5D,QAChB0D,EAAKE,MAAM,KAAKC,KAAKC,OAEd,IAAIlC,MAAJ,OACET,EADF,kEALT,EChGF,IAAM4C,EAAa,aACbC,EAAa,aAuBnB,IAAAC,EArBA,SAAkCC,GAkBhC,YAlByE,IAAzCA,MAAQC,SAASC,cAAc,UAC/D,IAAIC,iBAAiB,WACnBH,EAAMI,cAAc,IAAIC,MAAMR,MAC7BS,QAAQN,GACTO,iBAAkB,UAMpBvG,OAAOC,eAAe+F,EAAO,OAC3B7F,IAAK,kBAAM6F,EAAMQ,YACjBC,IAAK,SAAAnC,GACH,IAAMoC,EAAI,IAAIL,MAAMP,GACpBY,EAAEC,aAAerC,EACjB0B,EAAMI,cAAcM,MAGjBV,GCyET,SAASY,EAAW7F,EAAG8F,EAAcC,EAAWC,GAE9C,IADA,IAAIC,EAAOD,EACFzH,EAAI,EAAGA,EAAIyB,EAAGzB,IAAK,CAC1B,IAAKuH,EAAa/E,OAGhB,MADA8E,EAAWtH,EAAGwH,EAAWD,EAAcG,GACvC,UAAgBjG,EAAhB,4BAEF+F,EAAUG,KAAKD,GACfA,EAAOH,EAAaK,MAEtB,OAAOF,EAeT,SAASG,EAAcvF,EAAMiF,EAAcC,EAAWC,EAAaK,GACjE,IAAIJ,EAAOD,EACX,GAAKnF,EAAKE,OAAV,CAGA,IAAK,IAAIxC,EAAI,EAAGA,GAAKuH,EAAa/E,OAAQxC,IACxC,IAA6D,IAAzDsC,EAAKyF,QAAQR,EAAaA,EAAa/E,OAASxC,IAClD,OAAOsH,EAAWtH,EAAGuH,EAAcC,EAAWE,GAGlD,GAAKI,EAAL,CAGA,GAzBF,SAAwBxF,EAAMoF,GAC5B,IAAKpF,EAAKE,OACR,OAAO,EAET,IAAK,IAAIxC,EAAI,EAAGA,EAAIsC,EAAKE,OAAQxC,IAC/B,GAAI0H,IAASpF,EAAKtC,GAChB,OAAO,EAGX,OAAO,EAgBHgI,CAAe1F,EAAMoF,GAGvB,OAAOA,EAET,IAAIO,EACJ,GACEA,EAAW3F,EAAK4F,KAAKC,MAAMD,KAAKE,SAAW9F,EAAKE,eACzCkF,IAASO,QAAyB9B,IAAb8B,GAO9B,YAHa9B,KADbuB,EAAOJ,EAAWC,EAAa/E,OAAQ+E,EAAcC,EAAWE,KAE9DF,EAAUG,KAAKD,GAEVO,IAGT,IAAAI,EA7IA,WACE,SAAAC,EAAYhG,EAAMiG,QAAc,IAAdA,UAChBC,KAAKC,MAAQnG,EACbkG,KAAKE,iBACLF,KAAKG,cACLH,KAAKI,kBAAezC,EAEpBqC,KAAKK,kBAAoBC,QAAQP,EAAQQ,kBAP7C,IAAAC,EAAAV,EAAA1G,UAAA,OAAAoH,EAUEC,aAVF,SAUeC,GAWX,YAVqB/C,IAAjB+C,GACFV,KAAKW,gBAAgBD,GAEvBV,KAAKI,aAAef,EAClBW,KAAKC,MACLD,KAAKE,cACLF,KAAKG,WACLH,KAAKI,cACL,GAEKJ,KAAKI,cArBhBI,EAwBEI,iBAxBF,SAwBmBF,GAWf,YAVqB/C,IAAjB+C,GACFV,KAAKW,gBAAgBD,GAEvBV,KAAKI,aAAef,EAClBW,KAAKC,MACLD,KAAKG,WACLH,KAAKE,cACLF,KAAKI,aACLJ,KAAKK,mBAEAL,KAAKI,cAnChBI,EAsCEK,aAtCF,SAsCeC,EAAOJ,GAIlB,QAHqB/C,IAAjB+C,GACFV,KAAKW,gBAAgBD,QAEG/C,IAAtBqC,KAAKC,MAAMa,GAQf,YAL0BnD,IAAtBqC,KAAKI,cACPJ,KAAKG,WAAWhB,KAAKa,KAAKI,cAE5BJ,KAAKE,cAAclG,OAAS,EAC5BgG,KAAKI,aAAeJ,KAAKC,MAAMa,GACxBd,KAAKI,cAlDhBI,EAqDEO,QArDF,SAqDUjH,GACNkG,KAAKC,MAAQnG,GAtDjB0G,EAyDEQ,WAzDF,SAyDajB,GACT,IADkB,IAAAkB,EACF/I,OAAOgJ,KAAKnB,GAA5BoB,EAAA,EAAAA,EAAAF,EAAAjH,OAAAmH,IAAsC,CAAjC,IAAMlJ,OACT,OAAQA,GACN,IAAK,mBACH+H,KAAA,IAAS/H,GAAOqI,QAAQP,EAAQ9H,OA7D1CuI,EAqEEG,gBArEF,SAqEkBD,GACd,IAAMxB,EAAOc,KAAKC,MAAMS,GACpBV,KAAKI,eAAiBlB,IACxBc,KAAKoB,QACLpB,KAAKI,aAAelB,IAzE1BsB,EA6EEY,MA7EF,WA8EIpB,KAAKE,cAAclG,OAAS,EAC5BgG,KAAKG,WAAWnG,OAAS,EACzBgG,KAAKI,kBAAezC,GAhFxBmC,EAAA,GCNA,IAAAuB,EAJA,SAAyBC,GACvB,OAAOhB,QAAQgB,GAAYA,EAAStH,SCChCuH,IAAkB/E,IAAK,KAa7B,IAAAgF,EAXA,SAAyBF,EAAUR,GACjC,IAAKO,EAAgBC,GACnB,OAAOC,EAF+B,IAAAE,EAIfH,EAASR,GAA1B9D,EAJgCyE,EAIhCzE,QAASD,EAJuB0E,EAIvB1E,IACjB,OAAIC,EACKA,EAAQhD,OAASgD,EAAUuE,IAE1B/E,IAAKO,KCDjB,IAAA2E,EATA,SAA6BJ,EAAUvE,GACrC,OAAO4E,IAAeL,EAAU,SAAAM,GAC9B,OAAIA,EAAM5E,SACgE,IAAjE2E,IAAeC,EAAM5E,QAAS,SAAA6E,GAAA,OAAUA,EAAOrF,MAAQO,IAEzD6E,EAAM7E,KAAOA,IAAQ6E,EAAM7E,OCCtC,IAAA+E,EAJA,SAAuBR,GACrB,OAAQA,OAAgBS,IAAI,SAACC,EAAGxK,GAAJ,OAAUgK,EAAgBF,EAAU9J,GAAG,GAAGgF,OCMxE,IAAAyF,EAXA,SAA4BC,GAE1B,IADA,IAAMC,EAAkBxI,MAAMuI,EAAclI,QACnCxC,EAAI,EAAGA,EAAI0K,EAAclI,OAAQxC,IACxC2K,EAAgB3K,IACd4K,MAAOF,EAAcE,MAAM5K,GAC3B6K,IAAKH,EAAcG,IAAI7K,IAG3B,OAAO2K,GCET,IAAAG,EAVA,SAA2BC,EAAMC,GAC/B,OAAID,EACK,QAELC,EACK,WAEF,QCDT,IAAAC,EANA,SAA6CC,EAAQC,EAAKC,GAGxD,OAFAD,EAAqB,iBAARA,EAAmBA,GAAM,IACtCC,EAAqB,iBAARA,EAAmBA,EAAMC,IAC/BnD,KAAKkD,IAAID,EAAKjD,KAAKiD,IAAID,EAAQE,KCuExC,IAAAE,EA1EA,SAAoCC,EAAcC,EAAQC,GACxD,IAAMvJ,EAAMsJ,EAAOE,WAAW,MAC1BC,EAAY,KACZC,EAAW,KACXC,EAAY,KACZC,EAAmB,KAIvB,OAFAH,EAAYI,sBAeZ,SAASC,IAAiB,IAChBC,EAA4BV,EAA5BU,WAAYC,EAAgBX,EAAhBW,YAGhBC,EAAeZ,EACfa,EAAaH,EACbI,EAAcH,EACdI,EAAcL,EACdM,EAAeL,EACfM,GAAU,EAIRF,GAAeC,IAAiBT,IACpCK,EAAeL,EACfM,EAAaN,EAAiBW,aAC9BJ,EAAcP,EAAiBY,cAC/BJ,EAAcR,EAAiBW,aAC/BF,EAAeT,EAAiBY,cAChCF,GAAU,GAIRZ,GAAYC,GACdS,EAAcV,EACdW,EAAeV,GACND,GACTU,EAAcV,EACdW,EAAgBX,EAAWQ,EAAcC,GAChCR,IACTU,EAAeV,EACfS,EAAeT,EAAYQ,EAAeD,GAIxCZ,EAAOmB,QAAUL,GAAed,EAAOoB,SAAWL,IACpDf,EAAOmB,MAAQL,EACfd,EAAOoB,OAASL,GAIlBrK,EAAI2K,UAAUV,EAAc,EAAG,EAAGG,EAAaC,GAG3Cd,GACFA,EAASvJ,EAAKsK,GAGhBb,EAAYI,sBAAsBC,MA5DlCc,UADK,WAEHC,qBAAqBpB,IAEvBqB,cAJK,SAISL,EAAOC,GACnBhB,EAAWe,GAAS,KACpBd,EAAYe,GAAU,MAExBK,oBARK,SAQeC,GAClBpB,EAAmBoB,GAAO,62BCGhC,SAASC,EAAiBC,GAExB,GADAlK,EAASkK,GACQ,oBAAbA,EAAI7M,KAA4B,CAClC,IAAM8M,EACJ,6BACA,IAAIC,MAAOC,qBACX,oDACFnK,EAAWiK,IAOf,IAAMG,GACJ,gBACA,YACA,eACA,eAMIC,GAEJC,QAAQ,EAERC,YAAa,EAEbC,gBAAiB,EAIjBC,gBAAgB,EAKhBC,8BAA8B,EAE9BC,SAAU,EAEVC,kBAEAC,gBAEAC,kBAEAC,SAAS,EAETC,cAAc,GAIhB,SAASC,EAAkBC,EAAWhF,EAAOiF,QAAmB,IAAnBA,OAAa,GACxD,IAAMC,EAAaF,EAAUG,mBAAqBnF,EAClD,OACEmF,iBAAkBnF,EAClBoF,aAAcF,EACdb,YAAa,EACb5C,MAAMyD,GAAqBF,EAAUvD,KACrCqD,aAActF,QAAQyF,GACtBb,QAASa,GAOb,IAAaI,GAAb,SAAAC,GACE,SAAAC,EAAYnL,GAAO,IAAAoL,EAAA,OACjBA,EAAAF,EAAAzO,KAAAqI,KAAM9E,IAAN8E,MAEKuG,MAALC,KACKvB,GAEHgB,iBAAkBxD,EAChBvH,EAAMuL,mBACN,GAGFP,aAAc7E,EAAgBnG,EAAMoG,UAEpC6D,YAAa1C,EAAoCvH,EAAMwL,aAAc,GAErEC,OAAQlE,EAAoCvH,EAAM0L,cAAe,EAAG,GAEpEC,MAAO3L,EAAM4L,aAEbvE,KAAsC,UAAhCrH,EAAM6L,sBAEZvE,MAAuC,aAAhCtH,EAAM6L,sBAEbC,QAAS9L,EAAM+L,eAEfC,aAAchM,EAAMiM,oBAEpBC,qBAAqB,EAErBxB,aAAc1K,EAAMmM,UAAYhG,EAAgBnG,EAAMoG,UAEtDgG,aAAcpM,EAAMoG,UAEhBpG,EAAMqM,qBC1FT,SAAkCC,EAAUtM,GAAO,IAAAuM,EAYpDD,EAASE,aAVXxC,EAFsDuC,EAEtDvC,OACAC,EAHsDsC,EAGtDtC,YACAc,EAJsDwB,EAItDxB,iBACAU,EALsDc,EAKtDd,OACAE,EANsDY,EAMtDZ,MACAtE,EAPsDkF,EAOtDlF,KACAC,EARsDiF,EAQtDjF,MACAwE,EATsDS,EAStDT,QACAE,EAVsDO,EAUtDP,aACAS,EAXsDF,EAWtDE,eAEIC,KACFvG,EAAgBnG,EAAMoG,WAA+B,kBAAX4D,IAE5C0C,EAAoBhC,cAAgBV,GAEhB,iBAAXyB,GAAuBA,GAAU,GAAKA,GAAU,IACzDiB,EAAoBjB,OAASA,GAEV,kBAAVE,IACTe,EAAoBf,MAAQA,GAEV,kBAATtE,IACTqF,EAAoBrF,KAAOA,GAER,kBAAVC,IACToF,EAAoBpF,MAAQA,GAEP,kBAAZwE,IACTY,EAAoBZ,QAAUA,GAEJ,iBAAjBE,IACTU,EAAoBV,aAAeA,GAErC,IAAIW,GAAiB,EACrB,GAC4B,iBAAnBF,GACqB,iBAArB1B,GACPA,GAAoB,EAIpB,GAAI0B,IADenG,EAAgBtG,EAAMoG,SAAU2E,GAAkB,GAAGzJ,IAEtEoL,EAAoB3B,iBAAmBA,EACvC4B,GAAiB,MACZ,CAIL,IAAMC,EAAgBpG,EAAoBxG,EAAMoG,SAAUqG,IACnC,IAAnBG,IACFF,EAAoB3B,iBAAmB6B,EACvCD,GAAiB,GAOvB,OAHIA,GAAyC,iBAAhB1C,GAA4BA,GAAe,IACtEyC,EAAoBzC,YAAcA,GAE7ByC,ED8BCG,CAAyB7M,EAAMqM,qBAAsBrM,OAK3DoL,EAAK0B,iBAAmB1B,EAAKC,MAAMI,OAGnCL,EAAK2B,SAAW,IAAIpI,EAAeiC,EAAc5G,EAAMoG,WACrDf,iBAAkBrF,EAAMqF,mBAI1B+F,EAAKpI,MAAQ,KAEboI,EAAK4B,mBAAqB5B,EAAK4B,mBAAmBlP,KAAxBmP,EAAA7B,IAG1BA,EAAK8B,YAAc9B,EAAK8B,YAAYpP,KAAjBmP,EAAA7B,IACnBA,EAAK+B,iBAAmB/B,EAAK+B,iBAAiBrP,KAAtBmP,EAAA7B,IACxBA,EAAKgC,YAAchC,EAAKgC,YAAYtP,KAAjBmP,EAAA7B,IACnBA,EAAKiC,SAAWjC,EAAKiC,SAASvP,KAAdmP,EAAA7B,IAChBA,EAAKkC,YAAclC,EAAKkC,YAAYxP,KAAjBmP,EAAA7B,IACnBA,EAAKmC,aAAenC,EAAKmC,aAAazP,KAAlBmP,EAAA7B,IACpBA,EAAKoC,UAAYpC,EAAKoC,UAAU1P,KAAfmP,EAAA7B,IACjBA,EAAKqC,kBAAoBrC,EAAKqC,kBAAkB3P,KAAvBmP,EAAA7B,IACzBA,EAAKsC,YAActC,EAAKsC,YAAY5P,KAAjBmP,EAAA7B,IACnBA,EAAKuC,cAAgBvC,EAAKuC,cAAc7P,KAAnBmP,EAAA7B,IACrBA,EAAKwC,kBAAoBxC,EAAKwC,kBAAkB9P,KAAvBmP,EAAA7B,IACzBA,EAAKyC,gBAAkBzC,EAAKyC,gBAAgB/P,KAArBmP,EAAA7B,IACvBA,EAAK0C,wBAA0B1C,EAAK0C,wBAAwBhQ,KAA7BmP,EAAA7B,IAG/BA,EAAK2C,gBAAkB3C,EAAK2C,gBAAgBjQ,KAArBmP,EAAA7B,IACvBA,EAAK4C,iBAAmB5C,EAAK4C,iBAAiBlQ,KAAtBmP,EAAA7B,IACxBA,EAAK6C,sBAAwB7C,EAAK6C,sBAAsBnQ,KAA3BmP,EAAA7B,IAC7BA,EAAK8C,iBAAmB9C,EAAK8C,iBAAiBpQ,KAAtBmP,EAAA7B,IACxBA,EAAK+C,mBAAqB/C,EAAK+C,mBAAmBrQ,KAAxBmP,EAAA7B,IAC1BA,EAAKgD,0BAA4BhD,EAAKgD,0BAA0BtQ,KAA/BmP,EAAA7B,IACjCA,EAAKiD,sBAAwBjD,EAAKiD,sBAAsBvQ,KAA3BmP,EAAA7B,IAC7BA,EAAKkD,0BAA4BlD,EAAKkD,0BAA0BxQ,KAA/BmP,EAAA7B,IACjCA,EAAKmD,wBAA0BnD,EAAKmD,wBAAwBzQ,KAA7BmP,EAAA7B,IAC/BA,EAAKoD,0BAA4BpD,EAAKoD,0BAA0B1Q,KAA/BmP,EAAA7B,IACjCA,EAAKqD,oBAAsBrD,EAAKqD,oBAAoB3Q,KAAzBmP,EAAA7B,IAC3BA,EAAKsD,sBAAwBtD,EAAKsD,sBAAsB5Q,KAA3BmP,EAAA7B,IAC7BA,EAAKuD,sBAAwBvD,EAAKuD,sBAAsB7Q,KAA3BmP,EAAA7B,IA/EZA,EADrBwD,EAAAzD,EAAAD,GAAA,IAAA5F,EAAA6F,EAAAjN,UAAA,OAAAoH,EAmFEuJ,kBAnFF,WAmFsB,IAAAC,EAAAhK,KACZ9B,EAAS8B,KAAK9B,MAAQD,EAAyB+B,KAAK9B,OApIzC,IAuIbA,EAAM+L,aAMR/L,EAAMiH,YAAcnF,KAAKuG,MAAMpB,aAEjCjH,EAAMyI,OAAS3G,KAAKuG,MAAMI,OAC1BzI,EAAM2I,MAAQ7G,KAAKuG,MAAMM,MACzB3I,EAAMiJ,oBAAsBnH,KAAK9E,MAAMiM,oBACvCjJ,EAAMgJ,aAAelH,KAAKuG,MAAMW,aAGhChJ,EAAMgM,iBAAiB,aAAclK,KAAKmJ,uBAC1CjL,EAAMgM,iBAAiB,aAAclK,KAAK4J,uBAEtC5J,KAAKuG,MAAMX,eACb5F,KAAKmK,UACHvE,cAAc,IAEhB5F,KAAKoK,aAAeC,WAAW,WAC7BL,EAAK5B,aAAY,IACoB,IAApCpI,KAAK9E,MAAMoP,0BA9GpBjE,EAkHSkE,yBAlHT,SAkHkCC,EAAW1E,GACzC,IAAM2E,EAAcD,EAAUlJ,SAE9B,GAAImJ,IAAgB3E,EAAUwB,aAG5B,OAAO,KAGT,IAAMoD,GACJpD,aAAcmD,GAIhB,IAAKpJ,EAAgBoJ,GACnB,OAAAjE,KACKvB,EACAyF,GACHzE,iBAAkB,EAClBC,cAAc,IAKlB,IAAMyE,EAAcnJ,EAClBsE,EAAUwB,aACVxB,EAAUG,kBAGN2E,EAAiBpJ,EACrBiJ,EACA3E,EAAUG,kBAGZ,GAAI0E,EAAY,GAAGnO,MAAQoO,EAAe,GAAGpO,IAE3C,OAAOkO,EAMT,IAAM5C,EAAgBpG,EAAoB+I,EAAaE,EAAY,GAAGnO,KACtE,OACEgK,KACKkE,GAFgB,IAAnB5C,GAGA7B,iBAAkB6B,GAOjBjC,EAAkBC,EAAW,GAAG,KAvKzCtF,EA2KEqK,mBA3KF,SA2KqBC,EAAWhF,GAAW,IAAAiF,EAAA/K,KACvCA,KAAK9B,MAAMiJ,oBAAsBnH,KAAK9E,MAAMiM,oBAE5CnH,KAAKiI,SAASlH,QAAQe,EAAc9B,KAAK9E,MAAMoG,WAC/CtB,KAAKiI,SAASjH,YACZT,iBAAkBP,KAAK9E,MAAMqF,mBAG/B,IAAMoK,EAAcnJ,EAClBsJ,EAAUxJ,SACVwE,EAAUG,kBAEN+E,EAAaxJ,EACjBxB,KAAK9E,MAAMoG,SACXtB,KAAKuG,MAAMN,kBAET0E,EAAY,GAAGnO,MAAQwO,EAAW,GAAGxO,MAEvCwD,KAAK9B,MAAM+M,OAENjL,KAAKuG,MAAMS,SAKdhH,KAAKiI,SAAS7G,SAId0J,IAAc9K,KAAK9E,OAAU8E,KAAK9B,MAAMgH,QAE1ClF,KAAKkL,oBAGHlL,KAAKuG,MAAMX,eACb5F,KAAKmK,UACHvE,cAAc,IAIhByE,WAAW,WACTU,EAAK3C,aAAY,MAIrB+C,aAAanL,KAAKoL,uBAClBpL,KAAKoL,sBAAwBf,WAAW,WAClCU,EAAK7P,MAAMmQ,iBACbN,EAAK7P,MAAMmQ,gBClTZ,SAA0B9E,GAAO,IAEpCrB,EAUEqB,EAVFrB,OACAC,EASEoB,EATFpB,YACAc,EAQEM,EARFN,iBACAU,EAOEJ,EAPFI,OACAE,EAMEN,EANFM,MACAtE,EAKEgE,EALFhE,KACAC,EAIE+D,EAJF/D,MACAwE,EAGET,EAHFS,QACAE,EAEEX,EAFFW,aACAI,EACEf,EADFe,aAEF,OACEI,cACExC,SACAC,cACAc,mBACAU,SACAE,QACAtE,OACAC,QACAwE,UACAE,eACAS,eAAgBtG,EAAgBiG,GAC5B9F,EAAgB8F,EAAcrB,GAAkB,GAAGzJ,IACnD,ODwRyB8O,CAAiBP,EAAKxE,SAElD,MA7NP/F,EAgOE+K,qBAhOF,WAgOyB,IACbrN,EAAU8B,KAAV9B,MAERA,EAAMsN,oBAAoB,aAAcxL,KAAKmJ,uBAC7CjL,EAAMsN,oBAAoB,aAAcxL,KAAK4J,uBAE7CuB,aAAanL,KAAKyL,kBAClBN,aAAanL,KAAKoK,eAvOtB5J,EA0OE0H,mBA1OF,SA0OqBwD,GACjB1L,KAAK9B,MAAQwN,EAC6B,mBAA/B1L,KAAK9E,MAAMyQ,iBACpB3L,KAAK9E,MAAMyQ,gBAAgBD,IA7OjClL,EAiPE0K,kBAjPF,WAiPsB,IAAAU,EAAA5L,KAGd9I,OAAO2U,cAAgBC,UAAUC,wBAAwBF,eAK7DC,UAAUC,aAAaC,SAAW,IAAIC,cACpCjM,KAAK9E,MAAMoG,SAAStB,KAAKuG,MAAMN,mBAEjCjB,EACGjD,IAAI,SAAAmK,GACH,IAAiE,IAA7DN,EAAK1Q,MAAMiR,6BAA6B5M,QAAQ2M,GAClD,OAAO,KAET,IAAME,EAAaR,EAAK1Q,MAAMmR,gCAC9B,OAAQH,GACN,IAAK,OACH,OAAON,EAAKxD,YAAYpP,KAAK4S,GAAM,GACrC,IAAK,QACH,OAAOA,EAAKxD,YAAYpP,KAAK4S,GAAM,GACrC,IAAK,gBACH,OAAOA,EAAKrD,SACd,IAAK,YACH,OAAOqD,EAAKtD,YACd,IAAK,eACH,OAAO,kBAAOsD,EAAK1N,MAAMiH,aAAeiH,GAC1C,IAAK,cACH,OAAO,kBAAOR,EAAK1N,MAAMiH,aAAeiH,GAC1C,QACE,UAGLE,QAAQ,SAACC,EAAS/U,GACjBsU,UAAUC,aAAaS,iBACrBxH,EAA+BxN,GAC/B+U,OAtRV/L,EA2REwI,wBA3RF,SA2R0BhG,EAAQC,GAC9B,OAAOH,EAA2B9C,KAAK9B,MAAO8E,EAAQC,IA5R1DzC,EA+REyI,gBA/RF,WAgSIjJ,KAAKmK,SAAS,SAAA5D,GAAA,OAA2B,IAAjBA,EAAMrB,OAAmB,MAASA,QAAQ,KAClElF,KAAKkL,qBAjST1K,EAoSE0I,iBApSF,WAqSIlJ,KAAKmK,SAAS,SAAA5D,GAAA,OAA2B,IAAjBA,EAAMrB,OAAkB,MAASA,QAAQ,MArSrE1E,EAwSE2I,sBAxSF,SAwSwBvK,GAAG,IACf0C,EAAatB,KAAK9E,MAAlBoG,SACFtE,EAAUwE,EAAgBF,EAAUtB,KAAKuG,MAAMN,kBACrD,IAAgE,IAA5DtE,IAAe3E,EAAS,SAAAzD,GAAA,OAAKA,EAAEiD,MAAQoC,EAAEC,eAA7C,CAMA,IAAMiJ,EAAgBpG,EAAoBJ,EAAU1C,EAAEC,eAC/B,IAAnBiJ,EAQJ9H,KAAKqI,iBAAiBP,GAPpBpN,EACE,WAAWkE,EAAEC,aAAb,kJApTR2B,EA6TE4I,iBA7TF,WA8TI,IAAIpJ,KAAKuG,MAAMlB,eAAf,CAKA8F,aAAanL,KAAKyL,kBAND,IAAAgB,EAOsCzM,KAAK9E,MAApDoG,EAPSmL,EAOTnL,SAAUoL,EAPDD,EAOCC,iCAClB,GAAKrL,EAAgBC,GAArB,CARiB,IAAAqL,EAWmB3M,KAAKuG,MAAjC/D,EAXSmK,EAWTnK,MAAOyD,EAXE0G,EAWF1G,kBACVzD,GAASyD,EAAmB,GAAK3E,EAAStH,OACzC0S,GACF1M,KAAK4M,UAAU,GAAG,GAItB5M,KAAKyL,iBAAmBpB,WACtBrK,KAAKsI,YAC2B,IAAhCtI,KAAK9E,MAAM2R,uBAjVjBrM,EAqVE6I,mBArVF,WAsVIrJ,KAAKmK,SAAS,SAAA5D,GAAA,OAA4B,IAAlBA,EAAMZ,QAAmB,MAASA,SAAS,MAtVvEnF,EAyVE8I,0BAzVF,WA0VItJ,KAAKmK,SACH,SAAA5D,GAAA,OAA4B,IAAlBA,EAAMZ,QAAoB,MAASA,SAAS,MA3V5DnF,EA+VE+I,sBA/VF,WA+V0B,IAAAuD,EACU9M,KAAK9B,MAA7BiH,EADc2H,EACd3H,YAAa4H,EADCD,EACDC,OACrB/M,KAAKmK,UACHhF,cACAM,aAAcxD,EAAmB8K,MAnWvCvM,EAuWEgJ,0BAvWF,WAwWQxJ,KAAK9B,MAAMiH,cAAgBnF,KAAKuG,MAAMpB,cACxCnF,KAAK9B,MAAMiH,YAAcnF,KAAKuG,MAAMpB,aAEtCnF,KAAKmK,SACH,SAAA5D,GAAA,OAAiC,IAAvBA,EAAML,aAAyB,MAASA,cAAc,MA5WtE1F,EAgXEiJ,wBAhXF,WAgX4B,IAAAuD,EACEhN,KAAK9B,MAAvByI,EADgBqG,EAChBrG,OAAQE,EADQmG,EACRnG,MAChB7G,KAAKmK,UAAWxD,SAAQE,WAlX5BrG,EAqXEkJ,0BArXF,WAqX8B,IAClBnE,EAAavF,KAAK9B,MAAlBqH,SACRvF,KAAKmK,UAAW5E,cAvXpB/E,EA0XEmJ,oBA1XF,WA2XI3J,KAAKmK,UACH3E,eAAgBvD,EAAmBjC,KAAK9B,MAAM+O,UAC9CvH,eAAgBzD,EAAmBjC,KAAK9B,MAAMgP,aA7XpD1M,EAiYEoJ,sBAjYF,WAiY0B,IACdrH,EAASvC,KAAK9B,MAAdqE,KACRvC,KAAKmK,SAAS,SAAA5D,GAAA,OAAUA,EAAMhE,OAASA,EAAO,MAASA,WAnY3D/B,EAsYEqJ,sBAtYF,WAsY0B,IACd3C,EAAiBlH,KAAK9B,MAAtBgJ,aACRlH,KAAKmK,SACH,SAAA5D,GAAA,OAAUA,EAAMW,eAAiBA,EAAe,MAASA,mBAzY/D1G,EA6YE4H,YA7YF,SA6Yc3P,GAGV,GAFA0S,aAAanL,KAAKoK,cACa,kBAAV3R,EAAsBA,GAASuH,KAAKuG,MAAMrB,OAE7DlF,KAAK9B,MAAMiP,aAGb,GAAKnN,KAAK9B,MAAMQ,WAGhB,IACE,IAAM0O,EAAcpN,KAAK9B,MAAMmP,OAC3BD,GAA4C,mBAAtBA,EAAYE,OACpCF,EACGE,MAAM,SAAA1I,GAIL,GAAiB,eAAbA,EAAI7M,KACN,OAAOwV,QAAQC,OAAO5I,KAGzB0I,MAAM3I,GAEX,MAAOC,GACPD,EAAiBC,KAtavBpE,EA2aEoM,UA3aF,SA2aY9L,EAAOiF,QAAmB,IAAnBA,OAAa,GAC5BoF,aAAanL,KAAKoK,cAClBpK,KAAKmK,SAAS,SAAA5D,GAAA,OAASV,EAAkBU,EAAOzF,EAAOiF,MA7a3DvF,EAgbE6H,iBAhbF,SAgbmBvH,GAAO,IACdQ,EAAatB,KAAK9E,MAAlBoG,SACHD,EAAgBC,KAGjBR,EAAQ,GAAKA,EAAQQ,EAAStH,OAChCY,oBAA6BkG,EAA7B,uBAGEd,KAAKuG,MAAMS,SACbhH,KAAKiI,SAASpH,aAAaC,EAAOd,KAAKuG,MAAMN,kBAE/CjG,KAAK4M,UAAU9L,MA5bnBN,EA+bE+H,SA/bF,WA+ba,IAAAkF,EACqCzN,KAAK9E,MAA3CoG,EADCmM,EACDnM,SAAUoM,EADTD,EACSC,wBACVxP,EAAU8B,KAAV9B,MAFCyP,EAGoC3N,KAAKuG,MAA1C/D,EAHCmL,EAGDnL,MAAOyD,EAHN0H,EAGM1H,iBAAkBe,EAHxB2G,EAGwB3G,QACjC,IACG3F,EAAgBC,IACjBpD,EAAMiH,aAAeuI,IACnBlL,GAASyD,EAAmB,EAE9B/H,EAAMiH,YAAc,MALtB,CAQA,IAAIrE,EACJ,GAAIkG,EAAS,CACX,IAAM4G,EAAe5N,KAAKiI,SAASrH,iBAAiBqF,GACpD,QAAqBtI,IAAjBiQ,EAGF,YADA1P,EAAMiH,YAAc,GAGtBrE,EAAQY,EAAoBJ,EAAUsM,QAEtC9M,EAAQmF,EAAmB,GACf,IACVnF,EAAQQ,EAAStH,OAAS,GAG9BgG,KAAK4M,UAAU9L,KA1dnBN,EA6dE8H,YA7dF,WA6dgB,IASRxH,EARIQ,EAAatB,KAAK9E,MAAlBoG,SADIuM,EAEiC7N,KAAKuG,MAA1C/D,EAFIqL,EAEJrL,MAAOyD,EAFH4H,EAEG5H,iBAAkBe,EAFrB6G,EAEqB7G,SAE9B3F,EAAgBC,KACfkB,GAASyD,EAAmB,GAAK3E,EAAStH,SAK1CgN,EACFlG,EAAQY,EACNJ,EACAtB,KAAKiI,SAASxH,aAAawF,KAG7BnF,EAAQmF,EAAmB,IACd3E,EAAStH,SACpB8G,EAAQ,GAGZd,KAAK4M,UAAU9L,KAlfnBN,EAqfEgI,YArfF,SAqfcsF,GACV,GAAKzM,EAAgBrB,KAAK9E,MAAMoG,UAAhC,CAGA,IAAMyM,GACJ3I,gBAAiB0I,EACjBzI,gBAAgB,GAElB,OAAQrF,KAAK9E,MAAMsC,UACjB,IAAK,SACHwC,KAAKmK,SAAS,SAAA6D,GAAA,IAAG9I,EAAH8I,EAAG9I,OAAQI,EAAX0I,EAAW1I,6BAAX,OAAAkB,KACTuH,GACHzI,8BAA8BJ,GAC1BI,MAGNtF,KAAK9B,MAAMiH,YAAc2I,EACpB9N,KAAKuG,MAAMrB,QACdlF,KAAKoI,aAAY,GAEnB,MACF,IAAK,YACHpI,KAAKmK,SAAS,SAAA8D,GAAA,IAAG/I,EAAH+I,EAAG/I,OAAQI,EAAX2I,EAAW3I,6BAAX,OAAAkB,KACTuH,GACHzI,8BAA8BJ,GAC1BI,MAGNtF,KAAK9B,MAAMiH,YAAc2I,EACrB9N,KAAKuG,MAAMjB,+BAAiCtF,KAAK9B,MAAMgQ,OAGzDlO,KAAKoI,aAAY,GAEnB,MACF,IAAK,YACHpI,KAAKmK,SAAS4D,MAzhBtBvN,EA8hBEiI,aA9hBF,WA8hBiB,IAAA0F,EAC6CnO,KAAKuG,MAAvDnB,EADK+I,EACL/I,gBAAiBE,EADZ6I,EACY7I,6BACnByI,GACJ1I,gBAAgB,EAChBC,8BAA8B,GAE5BxH,MAAMsH,GACRpF,KAAKmK,SAAS4D,IAGhB/N,KAAKmK,SAAL3D,KACKuH,GAMH5I,YAAaC,KAEfpF,KAAK9B,MAAMiH,YAAcC,EACrBE,IACEtF,KAAK9B,MAAMgQ,MACblO,KAAKsI,cAELtI,KAAKoI,aAAY,MAtjBzB5H,EA2jBEkI,UA3jBF,SA2jBY/B,GACH3G,KAAKuG,MAAMa,qBACdpH,KAAKmK,UACH/C,qBAAqB,IAGzB,IAAMgH,EAAiB3L,EAAoCkE,EAAQ,EAAG,GACtE3G,KAAK9B,MAAM2I,MAA2B,IAAnBuH,EACnBpO,KAAK9B,MAAMyI,OAASyH,GAnkBxB5N,EAskBEmI,kBAtkBF,WAukBI3I,KAAKmK,UACH/C,qBAAqB,IAElBpH,KAAK9B,MAAM2I,QACd7G,KAAKgI,iBAAmBhI,KAAK9B,MAAMyI,SA3kBzCnG,EA+kBEoI,YA/kBF,SA+kBcnQ,GACV,IAAMoO,EAAyB,kBAAVpO,EAAsBA,GAASuH,KAAKuG,MAAMM,MAC/D7G,KAAK9B,MAAM2I,MAAQA,EACdA,IACH7G,KAAK9B,MAAMyI,OAAS3G,KAAKgI,mBAnlB/BxH,EAulBEqI,cAvlBF,SAulBgBpQ,GACZ,IAAMuO,EAA2B,kBAAVvO,EAAsBA,GAASuH,KAAKuG,MAAMS,QACjEhH,KAAKmK,UAAWnD,aAzlBpBxG,EA4lBEsI,kBA5lBF,SA4lBoBuF,IACuC,IAAnD9T,EAAsBgF,QAAQ8O,GAUlCrO,KAAKmK,SAAS,WACZ,OAAQkE,GACN,IAAK,QACH,OACE9L,MAAM,GAEV,IAAK,WACH,OACEA,MAAM,EACNC,OAAO,GAEX,IAAK,OACH,OACED,MAAM,EACNC,OAAO,GAEX,QACE,OAAO,QA1BX5H,EACE,mBACEyT,EACA,oBACA9T,EAAsBqD,MAAM,MAC5B,MAnmBV4C,EA6nBEuI,gBA7nBF,SA6nBkBuF,GACdtO,KAAK9B,MAAMgJ,aAAeoH,GA9nB9B9N,EAioBE+N,gBAjoBF,WAioBoB,IACRrT,EAAiB8E,KAAjB9E,MAAOqL,EAAUvG,KAAVuG,MACTiI,GACJlN,SAAUpG,EAAMoG,SAChB2E,iBAAkBM,EAAMN,iBACxBC,aAAcK,EAAML,aACpBhB,OAAQqB,EAAMrB,OACdC,YAAaoB,EAAMpB,YACnBC,gBAAiBmB,EAAMnB,gBACvBC,eAAgBkB,EAAMlB,eACtBC,6BAA8BiB,EAAMjB,6BACpCC,SAAUgB,EAAMhB,SAChBC,eAAgBe,EAAMf,eACtBC,aAAcc,EAAMd,aACpBC,eAAgBa,EAAMb,eACtBiB,OAAQJ,EAAMI,OACdE,MAAON,EAAMM,MACbG,QAAST,EAAMS,QACfrB,QAASY,EAAMZ,QACfuB,aAAcX,EAAMW,aACpBE,oBAAqBb,EAAMa,oBAC3BiH,eAAgB/L,EAAkBiE,EAAMhE,KAAMgE,EAAM/D,OACpDwG,wBAAyBhJ,KAAKgJ,wBAC9ByF,cAAezO,KAAKoI,YACpBsG,mBAAoB1O,KAAKqI,iBACzBsG,WAAY3O,KAAKuI,SACjBqG,cAAe5O,KAAKsI,YACpBuG,cAAe7O,KAAKwI,YACpBsG,eAAgB9O,KAAKyI,aACrBsG,YAAa/O,KAAK0I,UAClBsG,oBAAqBhP,KAAK2I,kBAC1BsG,cAAejP,KAAK4I,YACpBsG,gBAAiBlP,KAAK6I,cACtBsG,oBAAqBnP,KAAK8I,kBAC1BsG,kBAAmBpP,KAAK+I,iBAE1B,GAAI/I,KAAKwO,cAEP,IAFsB,IAAAvN,EAEJ/I,OAAOgJ,KAAKlB,KAAKwO,eAAnCrN,EAAA,EAAAA,EAAAF,EAAAjH,OAAAmH,IAAmD,CAA9C,IAAMpI,OACT,GAAIyV,EAAczV,KAASiH,KAAKwO,cAAczV,GAAM,CAClDiH,KAAKwO,cAAgBA,EACrB,YAKJxO,KAAKwO,cAAgBA,EAEvB,OAAOxO,KAAKwO,eAjrBhBhO,EAorBE6O,OAprBF,WAqrBI,IAAMrS,EAAUwE,EACdxB,KAAK9E,MAAMoG,SACXtB,KAAKuG,MAAMN,kBAEPuI,EAAgBxO,KAAKuO,kBAC3B,OACEe,EAAAvT,EAAAqC,cAAClE,EAAA,SAAD,KACEoV,EAAAvT,EAAAqC,cAAA,SACEmR,QAAA,EACA7D,IAAK1L,KAAKkI,mBACVsH,YAAaxP,KAAK9E,MAAMsU,YACxBC,QAAQ,WACRlN,KAAMvC,KAAKuG,MAAMhE,KACjBmN,OAAQ1P,KAAKiJ,gBACb0G,QAAS3P,KAAKkJ,iBACd0G,QAAS5P,KAAKoJ,iBACdyG,UAAW7P,KAAKqJ,mBAChByG,iBAAkB9P,KAAKsJ,0BACvByG,aAAc/P,KAAKuJ,sBACnByG,iBAAkBhQ,KAAKwJ,0BACvByG,eAAgBjQ,KAAKyJ,wBACrByG,iBAAkBlQ,KAAK0J,0BACvByG,WAAYnQ,KAAK2J,oBACjByG,aAAcpQ,KAAK6J,uBAElB7M,EAAQ+E,IAAI,SAAAF,GAAA,OACXyN,EAAAvT,EAAAqC,cAAA,UAAQrF,IAAK8I,EAAOrF,IAAKA,IAAKqF,EAAOrF,IAAKE,KAAMmF,EAAOnF,UAG3D4S,EAAAvT,EAAAqC,cAAChE,EAAciW,UAAS5X,MAAO+V,GACG,mBAAxBxO,KAAK9E,MAAMoV,SACftQ,KAAK9E,MAAMoV,SAAS9B,GACpBxO,KAAK9E,MAAMoV,YArtBzBjK,EAAA,CAA2CnM,EAAA,WA4tB3CiM,GAAsBoK,WACpBjP,SAAUxF,EAAAC,EAAUkB,QAAQH,EAAsBrB,YAAYA,WAC9D4L,SAAUvL,EAAAC,EAAUyU,KAAK/U,WACzB6O,uBAAwBxO,EAAAC,EAAU2G,OAAOjH,WACzCoR,mBAAoB/Q,EAAAC,EAAU2G,OAAOjH,WACrC+T,YAAapT,EACbwK,cAAe9K,EAAAC,EAAU2G,OAAOjH,WAChCqL,aAAchL,EAAAC,EAAUyU,KACxBzJ,sBAAuB1K,EAA+BZ,WACtDwL,eAAgBnL,EAAAC,EAAUyU,KAC1BrJ,oBAAqBrL,EAAAC,EAAU2G,OAAOjH,WACtCiL,aAAc5K,EAAAC,EAAU2G,OAAOjH,WAC/BgL,mBAAoB3K,EAAAC,EAAU2G,OAAOjH,WACrCiR,iCAAkC5Q,EAAAC,EAAUyU,KAC5ChT,SAAUA,EAAyB/B,WACnCgV,qBAAsB3U,EAAAC,EAAUyU,KAAK/U,WACrC8E,iBAAkBzE,EAAAC,EAAUyU,KAC5B9C,wBAAyB5R,EAAAC,EAAU2G,OAAOjH,WAC1C0Q,6BAA8BrQ,EAAAC,EAAUkB,QACtCN,EAAmClB,YACnCA,WACF4Q,gCAAiCvQ,EAAAC,EAAU2G,OAAOjH,WAClDkQ,gBAAiB7P,EAAAC,EAAUI,KAC3BoL,qBAAsBzL,EAAAC,EAAUQ,OAC9BmL,aAAc5L,EAAAC,EAAU7C,OAAOuC,aAEjC4P,gBAAiBvP,EAAAC,EAAUI,KAC3BmU,SAAUxU,EAAAC,EAAUG,WAAWJ,EAAAC,EAAU2U,KAAM5U,EAAAC,EAAUI,OAAOV,YAGlE0K,GAAsBwK,cACpBtJ,UAAU,EACViD,uBAAwB,EACxBuC,mBAAoB,EACpBjG,cAAe,EACfE,cAAc,EACdC,sBAAuB,WACvBE,gBAAgB,EAChBE,oBAAqB,EACrBT,aAAc,EACdD,mBAAoB,EACpBiG,kCAAkC,EAClClP,SAAU,YACViT,sBAAsB,EACtBlQ,kBAAkB,EAClBmN,wBAAyB,EACzBvB,8BAA+B,OAAQ,QAAS,gBAAiB,aACjEE,gCAAiC,IAGnC,IAAauE,GAAb,SAAAC,GAAA,SAAAC,IAAA,OAAAD,EAAAnV,MAAAsE,KAAA1E,YAAA0E,KAAA8J,EAAAgH,EAAAD,GAAA,IAAAE,EAAAD,EAAA1X,UAAA,OAAA2X,EACEhH,kBADF,WAEI/J,KAAK9E,MAAM8V,aAAaC,qBAAqBjR,KAAKkR,eAFtDH,EAKExF,qBALF,WAMIvL,KAAK9E,MAAM8V,aAAaG,uBAAuBnR,KAAKkR,eANxDH,EASE1B,OATF,WASW,IAAA+B,EAAApR,KAAAqR,EACyBrR,KAAK9E,MAA7B8V,EADDK,EACCL,aAAc9V,EADfmW,EACenW,MACdyQ,EAA6BzQ,EAA7ByQ,gBAAoBpQ,yTAFrB+V,CAE8BpW,GAF9B,oBAGP,OACEoU,EAAAvT,EAAAqC,cAAC+H,GAADoL,KACMP,EAAaQ,WACbjW,GACJoQ,gBAAiB,SAAAD,GACXC,GACFA,EAAgBD,GAElB0F,EAAKF,aAAexF,OApB9BoF,EAAA,CAA8C5W,EAAA,WA2B9C0W,GAAyBL,WACvBS,aAAclV,EAAAC,EAAUQ,OACtBiV,WAAY1V,EAAAC,EAAU7C,OAAOuC,WAC7BwV,qBAAsBnV,EAAAC,EAAUI,KAAKV,WACrC0V,uBAAwBrV,EAAAC,EAAUI,KAAKV,aACtCA,YAmBL,IAAAgW,GAhBA,SAAoCvW,GAClC,OACEoU,EAAAvT,EAAAqC,cAAC9D,EAAaoX,SAAd,KACG,SAAAV,GACC,OAAKA,EAGE9Y,OAAAgC,EAAA,cAAAhC,CAAc0Y,IACnBI,eACA9V,UAJOhD,OAAAgC,EAAA,cAAAhC,CAAciO,GAAuBjL,ikBEz4BtD,IAAayW,GAAb,SAAAvL,GACE,SAAAwL,EAAY1W,GAAO,IAAAoL,EAAA,OACjBA,EAAAF,EAAAzO,KAAAqI,KAAM9E,IAAN8E,MACKiR,qBAAuB3K,EAAK2K,qBAAqBjY,KAA1B6Y,GAAAvL,IAC5BA,EAAK6K,uBAAyB7K,EAAK6K,uBAAuBnY,KAA5B6Y,GAAAvL,IAC9BA,EAAKwL,0BAA4BxL,EAAKwL,0BAA0B9Y,KAA/B6Y,GAAAvL,IACjCA,EAAKyL,iBALYzL,gGADrB0L,CAAAJ,EAAAxL,GAAA,IAAA5F,EAAAoR,EAAAxY,UAAA,OAAAoH,EASEyQ,qBATF,SASuBgB,GACnBjS,KAAK+R,cAAgB/R,KAAK+R,cAAcpW,OAAOsW,GAC/CA,EAAK/H,iBAAiB,OAAQlK,KAAK8R,2BAA2B,GAC9DG,EAAK/H,iBAAiB,eAAgBlK,KAAK8R,2BAA2B,IAZ1EtR,EAeE2Q,uBAfF,SAeyBc,GACrBjS,KAAK+R,cAAgB/R,KAAK+R,cAAcG,OAAO,SAAAC,GAAA,OAAWF,IAASE,IACnEF,EAAKzG,oBAAoB,OAAQxL,KAAK8R,2BAA2B,GACjEG,EAAKzG,oBACH,eACAxL,KAAK8R,2BACL,IArBNtR,EAyBEsR,0BAzBF,SAyB4BlT,GACxB,IAAMsS,EAAetS,EAAEwT,OACflN,EAAkBgM,EAAlBhM,OAAQ2B,EAAUqK,EAAVrK,MAChB,IAAI3B,IAAU2B,EAGd,KAAAwL,EAAsBrS,KAAK+R,cAA3BO,EAAA3Y,MAAA4Y,QAAAF,GAAAlR,EAAA,MAAAkR,EAAAC,EAAAD,IAAA9Z,OAAAia,cAA0C,KAAAxE,EAAA,GAAAsE,EAAA,IAAAnR,GAAAkR,EAAArY,OAAA,MAAAgU,EAAAqE,EAAAlR,SAAA,KAAAA,EAAAkR,EAAAI,QAAAC,KAAA,MAAA1E,EAAA7M,EAAA1I,MAAA,IAA/B0Z,EAA+BnE,EACpCmE,IAAYjB,GAAiBiB,EAAQtL,OACvCsL,EAAQhF,WAjChB3M,EAsCE6O,OAtCF,WAsCW,IAAArF,EAAAhK,KACP,OACEsP,EAAAvT,EAAAqC,cAAC9D,EAAaoX,SAAd,KACG,SAAAV,GACC,IAAMvY,EAAQuY,EAAA2B,MAEL3B,GACHQ,WAAAmB,MAAiB3B,EAAaQ,WAAexH,EAAK9O,UAGlDsW,WAAYxH,EAAK9O,MACjB+V,qBAAsBjH,EAAKiH,qBAC3BE,uBAAwBnH,EAAKmH,wBAEnC,OACE7B,EAAAvT,EAAAqC,cAAC9D,EAAa+V,UAAS5X,MAAOA,GAC3BuR,EAAK9O,MAAMoV,aAtD1BsB,EAAA,CAAwC1X,EAAA,WA+DxCyX,GAAmBpB,WACjBD,SAAUxU,EAAAC,EAAU2U,KAAKjV,YAG3B,IAAAmX,GAAA,GCvEMC,GAAoB3a,OAAAgC,EAAA,cAAAhC,EACxB4a,YAAY,EACZC,kBAFsC,WAGpCnY,EACE,qFAIJoY,sBARsC,WASpCpY,EACE,4FAKNiY,GAAkB1Y,YAAc,oBAEhC,IAAA8Y,GAAA,+HChBA,IAAMC,IACJ/O,MAAO,OACPC,OAAQ,QAMG+O,GAAb,SAAAC,GACE,SAAAC,EAAYnY,GAAO,IAAAoL,EAAA,OACjBA,EAAA8M,EAAAzb,KAAAqI,KAAM9E,IAAN8E,MACKuG,OACHuM,YAAY,GAEdxM,EAAKyM,kBAAoBzM,EAAKyM,kBAAkB/Z,KAAvBsa,GAAAhN,IACzBA,EAAK0M,sBAAwB1M,EAAK0M,sBAAsBha,KAA3Bsa,GAAAhN,IAC7BA,EAAKiN,uBAAyBjN,EAAKiN,uBAAuBva,KAA5Bsa,GAAAhN,IAC9BA,EAAKkN,kBAAoB,KARRlN,gGADrBmN,CAAAJ,EAAAD,GAAA,IAAA5S,EAAA6S,EAAAja,UAAA,OAAAoH,EAYEuJ,kBAZF,WAaI5L,SAAS+L,iBAAiB,mBAAoBlK,KAAKuT,wBACnDpV,SAAS+L,iBACP,yBACAlK,KAAKuT,wBAEPpV,SAAS+L,iBACP,sBACAlK,KAAKuT,wBAEPpV,SAAS+L,iBACP,qBACAlK,KAAKuT,yBAxBX/S,EA4BE+K,qBA5BF,WA6BIpN,SAASqN,oBACP,mBACAxL,KAAKuT,wBAEPpV,SAASqN,oBACP,yBACAxL,KAAKuT,wBAEPpV,SAASqN,oBACP,sBACAxL,KAAKuT,wBAEPpV,SAASqN,oBACP,qBACAxL,KAAKuT,yBA3CX/S,EA+CEuS,kBA/CF,WAgDS/S,KAAK9E,MAAMwY,oBAGZ1T,KAAKwT,kBAAkBT,kBACzB/S,KAAKwT,kBAAkBT,oBACd/S,KAAKwT,kBAAkBG,wBAChC3T,KAAKwT,kBAAkBG,0BACd3T,KAAKwT,kBAAkBI,qBAChC5T,KAAKwT,kBAAkBK,uBACd7T,KAAKwT,kBAAkBM,qBAChC9T,KAAKwT,kBAAkBM,wBA1D7BtT,EA8DEwS,sBA9DF,WA+DQ7U,SAAS4V,eACX5V,SAAS4V,iBACA5V,SAAS6V,qBAClB7V,SAAS6V,uBACA7V,SAAS8V,uBAClB9V,SAAS8V,yBACA9V,SAAS+V,oBAClB/V,SAAS+V,sBACA/V,SAASgW,kBAClBhW,SAASiW,qBAxEf5T,EA4EE+S,uBA5EF,WA6EI,IAAMc,EACJlW,SAASqV,mBACTrV,SAASmW,yBACTnW,SAASoW,sBACTpW,SAASqW,oBACXxU,KAAKmK,UACH2I,WAAYuB,IAA8BrU,KAAKwT,qBAnFrDhT,EAuFEiU,qBAvFF,WAwFI,IAAMC,GACJ5B,WAAY9S,KAAKuG,MAAMuM,WACvBC,kBAAmB/S,KAAK+S,kBACxBC,sBAAuBhT,KAAKgT,uBAE9B,OACEhT,KAAK0U,mBACLA,EAAkB5B,aAAe9S,KAAK0U,kBAAkB5B,WAGjD9S,KAAK0U,kBAEN1U,KAAK0U,kBAAoBA,GApGrClU,EAuGE6O,OAvGF,WAuGW,IAAArF,EAAAhK,KACD0U,EAAoB1U,KAAKyU,uBAC/B,OACEnF,EAAAvT,EAAAqC,cAAA,OACEsN,IAAK,SAAAuG,GAAA,OAASjI,EAAKwJ,kBAAoBvB,GACvC0C,MAAO3U,KAAKuG,MAAMuM,WAAaI,QAAkBvV,GAEjD2R,EAAAvT,EAAAqC,cAAC6U,GAAkB5C,UAAS5X,MAAOic,GACD,mBAAxB1U,KAAK9E,MAAMoV,SACftQ,KAAK9E,MAAMoV,SAASoE,GACpB1U,KAAK9E,MAAMoV,YAjHzB+C,EAAA,CAA+CnZ,EAAA,eAwH/CiZ,GAA0B5C,WACxBmD,kBAAmB5X,EAAAC,EAAUyU,KAAK/U,WAClC6U,SAAUxU,EAAAC,EAAUG,WAAWJ,EAAAC,EAAU2U,KAAM5U,EAAAC,EAAUI,OAAOV,YAGlE0X,GAA0BxC,cACxB+C,mBAAmB,GAGrB,IAAAkB,GAAA,4HCjGA,IAAAC,GAvCA,SAA6BC,EAAWC,GACtC,IAAMC,KACAC,EAAYH,EAAU3a,aAAe2a,EAAU/c,KACrD,SAASmd,EAAoBha,GAC3B,OACEoU,EAAAvT,EAAAqC,cAAC6U,GAAkBvB,SAAnB,KACG,SAAAgD,GAAA,OACCpF,EAAAvT,EAAAqC,cAAChE,EAAcsX,SAAf,KACG,SAAAlD,GACC,IAAM2G,qUAAAC,IAAkBla,GACxBmX,EAAuB0C,EAAvBzC,EAAA3Y,MAAA4Y,QAAAF,GAAAlR,EAAA,MAAAkR,EAAAC,EAAAD,IAAA9Z,OAAAia,cAAyC,KAAAxE,EAAA,GAAAsE,EAAA,IAAAnR,GAAAkR,EAAArY,OAAA,MAAAgU,EAAAqE,EAAAlR,SAAA,KAAAA,EAAAkR,EAAAI,QAAAC,KAAA,MAAA1E,EAAA7M,EAAA1I,MAAA,IAA9B0C,EAA8B6S,EACnCQ,EAAcnV,eAAe8B,GAC/Bga,EAAWha,GAAYqT,EAAcrT,GAC5BuZ,EAAkBrb,eAAe8B,GAC1Cga,EAAWha,GAAYuZ,EAAkBvZ,GAC/B6Z,EAAO7Z,KACjBP,EACE,SACEO,EACA,mBACA8Z,EACA,qDAEJD,EAAO7Z,IAAY,GAGvB,OAAOjD,OAAAgC,EAAA,cAAAhC,CAAc4c,EAAWK,OAU5C,OAHIF,IACFC,EAAoB/a,YAApB,uBAAyD8a,EAAzD,KAEKC,smBCjCF,IAAMG,GAAwBjb,EAAcsX,SAGtC4D,GAA4BrC,GAAkBvB","file":"es5/cassette-core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cassetteCore\"] = factory(require(\"prop-types\"), require(\"react\"));\n\telse\n\t\troot[\"cassetteCore\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","'use strict';\nmodule.exports = function (arr, predicate, ctx) {\n\tif (typeof Array.prototype.findIndex === 'function') {\n\t\treturn arr.findIndex(predicate, ctx);\n\t}\n\n\tif (typeof predicate !== 'function') {\n\t\tthrow new TypeError('predicate must be a function');\n\t}\n\n\tvar list = Object(arr);\n\tvar len = list.length;\n\n\tif (len === 0) {\n\t\treturn -1;\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tif (predicate.call(ctx, list[i], i, list)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n};\n","import { createContext } from 'react';\n\nconst PlayerContext = createContext(null);\nPlayerContext.displayName = 'PlayerContext';\n\nexport default PlayerContext;\n","import { createContext } from 'react';\n\nconst GroupContext = createContext(null);\nGroupContext.displayName = 'GroupContext';\n\nexport default GroupContext;\n","export const repeatStrategyOptions = ['none', 'playlist', 'track'];\n","/* eslint-disable no-console */\n\nconst log = console.log.bind(console);\n\nexport const logError = console.error ? console.error.bind(console) : log;\nexport const logWarning = console.warn ? console.warn.bind(console) : log;\n","import PropTypes from 'prop-types';\n\nimport { repeatStrategyOptions } from './constants';\nimport { logWarning } from './utils/console';\n\nfunction requiredOnlyUnlessHasProp(propType, altPropName) {\n  let warnedAboutDefiningBoth = false;\n  function validate(props, propName, componentName, ...rest) {\n    if (propName in props) {\n      if (!warnedAboutDefiningBoth && altPropName in props) {\n        logWarning(\n          `Do not define both the '${propName}' and '${altPropName}' props.`\n        );\n        warnedAboutDefiningBoth = true;\n      }\n      return propType.isRequired(props, propName, componentName, ...rest);\n    }\n    if (!(altPropName in props)) {\n      return new Error(\n        `If the '${altPropName}' prop is not defined, '${propName}' must be.`\n      );\n    }\n  }\n  return validate;\n}\n\nexport const controlKeyword = PropTypes.oneOf([\n  'playpause',\n  'backskip',\n  'forwardskip',\n  'volume',\n  'mute',\n  'repeat',\n  'shuffle',\n  'progress',\n  'progressdisplay',\n  'fullscreen',\n  'spacer'\n]);\n\nexport const control = PropTypes.oneOfType([PropTypes.func, controlKeyword]);\n\nexport const crossOriginAttribute = PropTypes.oneOf([\n  'anonymous',\n  'use-credentials'\n]);\n\nexport const repeatStrategy = PropTypes.oneOf(repeatStrategyOptions);\n\nexport const mediaSource = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired\n});\n\nexport const mediaSessionAction = PropTypes.oneOf([\n  'play',\n  'pause',\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n]);\n\nexport const mediaSessionArtwork = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  sizes: PropTypes.string,\n  type: PropTypes.string\n});\n\nexport const track = PropTypes.shape({\n  url: requiredOnlyUnlessHasProp(PropTypes.string, 'sources'),\n  sources: requiredOnlyUnlessHasProp(\n    PropTypes.arrayOf(mediaSource.isRequired),\n    'url'\n  ),\n  title: PropTypes.string.isRequired,\n  artist: PropTypes.string,\n  album: PropTypes.string,\n  artwork: PropTypes.arrayOf(mediaSessionArtwork.isRequired),\n  meta: PropTypes.object\n});\n\nexport const progressDirection = PropTypes.oneOf([\n  'left',\n  'right',\n  'up',\n  'down'\n]);\n\nexport const seekMode = PropTypes.oneOf(['paused', 'immediate', 'onrelease']);\n\nexport function aspectRatio(props, propName) {\n  const prop = props[propName];\n  if (prop === undefined) {\n    return;\n  }\n  if (\n    typeof prop !== 'string' ||\n    prop.split(':').length !== 2 ||\n    prop.split(':').some(isNaN)\n  ) {\n    return new Error(\n      `The ${propName} prop should be a string of the form 'x:y'. Example: 16:9`\n    );\n  }\n}\n","const loopchange = 'loopchange';\nconst srcrequest = 'srcrequest';\n\nfunction createCustomMediaElement(media = document.createElement('media')) {\n  new MutationObserver(() => {\n    media.dispatchEvent(new Event(loopchange));\n  }).observe(media, {\n    attributeFilter: ['loop']\n  });\n  // Don't let the media src property get modified directly.\n  // Instead, when it does get set, dispatch an event to be\n  // handled in a way that doesn't conflict with the loaded\n  // playlist.\n  Object.defineProperty(media, 'src', {\n    get: () => media.currentSrc,\n    set: src => {\n      const e = new Event(srcrequest);\n      e.srcRequested = src;\n      media.dispatchEvent(e);\n    }\n  });\n  return media;\n}\n\nexport default createCustomMediaElement;\n","/* ShuffleManager\n *\n * Manages navigation throughout a list which is:\n * - Sourced from another provided list\n * - In random order (except to avoid consecutive duplicates)\n * - Extended endlessly on-the-fly, as needed\n * - Able to have future history overwritten by non-random choices\n * - Able to swap source lists and maintain shuffle order for common members\n */\n\nexport class ShuffleManager {\n  constructor(list, options = {}) {\n    this._list = list;\n    this._forwardStack = [];\n    this._backStack = [];\n    this._currentItem = undefined;\n\n    this._allowBackShuffle = Boolean(options.allowBackShuffle);\n  }\n\n  findNextItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._forwardStack,\n      this._backStack,\n      this._currentItem,\n      true\n    );\n    return this._currentItem;\n  }\n\n  findPreviousItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._backStack,\n      this._forwardStack,\n      this._currentItem,\n      this._allowBackShuffle\n    );\n    return this._currentItem;\n  }\n\n  pickNextItem(index, currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    if (this._list[index] === undefined) {\n      return undefined;\n    }\n    if (this._currentItem !== undefined) {\n      this._backStack.push(this._currentItem);\n    }\n    this._forwardStack.length = 0;\n    this._currentItem = this._list[index];\n    return this._currentItem;\n  }\n\n  setList(list) {\n    this._list = list;\n  }\n\n  setOptions(options) {\n    for (const o of Object.keys(options)) {\n      switch (o) {\n        case 'allowBackShuffle':\n          this[`_${o}`] = Boolean(options[o]);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  setCurrentIndex(currentIndex) {\n    const item = this._list[currentIndex];\n    if (this._currentItem !== item) {\n      this.clear();\n      this._currentItem = item;\n    }\n  }\n\n  clear() {\n    this._forwardStack.length = 0;\n    this._backStack.length = 0;\n    this._currentItem = undefined;\n  }\n}\n\nfunction _goForward(n, forwardStack, backStack, currentItem) {\n  let item = currentItem;\n  for (let i = 0; i < n; i++) {\n    if (!forwardStack.length) {\n      // rollback before erroring (note stack reversal)\n      _goForward(i, backStack, forwardStack, item);\n      throw `Moving ${n} places was not possible!`;\n    }\n    backStack.push(item);\n    item = forwardStack.pop();\n  }\n  return item;\n}\n\nfunction _allItemsMatch(list, item) {\n  if (!list.length) {\n    return false;\n  }\n  for (let i = 0; i < list.length; i++) {\n    if (item !== list[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction _findNextItem(list, forwardStack, backStack, currentItem, allowMore) {\n  let item = currentItem;\n  if (!list.length) {\n    return undefined;\n  }\n  for (let i = 1; i <= forwardStack.length; i++) {\n    if (list.indexOf(forwardStack[forwardStack.length - i]) !== -1) {\n      return _goForward(i, forwardStack, backStack, item);\n    }\n  }\n  if (!allowMore) {\n    return undefined;\n  }\n  if (_allItemsMatch(list, item)) {\n    // we can serve this as our \"next\" item but we\n    // won't modify our history since it's the same.\n    return item;\n  }\n  let nextItem;\n  do {\n    nextItem = list[Math.floor(Math.random() * list.length)];\n  } while (item === nextItem || nextItem === undefined);\n  // if we're skipping items that aren't in our current list we may\n  // have some items in our forwardStack - make sure we move to the front.\n  item = _goForward(forwardStack.length, forwardStack, backStack, item);\n  if (item !== undefined) {\n    backStack.push(item);\n  }\n  return nextItem;\n}\n\nexport default ShuffleManager;\n","function isPlaylistValid(playlist) {\n  return Boolean(playlist && playlist.length);\n}\n\nexport default isPlaylistValid;\n","import isPlaylistValid from './isPlaylistValid';\n\nconst blankSources = [{ src: '' }];\n\nfunction getTrackSources(playlist, index) {\n  if (!isPlaylistValid(playlist)) {\n    return blankSources;\n  }\n  const { sources, url } = playlist[index];\n  if (sources) {\n    return sources.length ? sources : blankSources;\n  }\n  return [{ src: url }];\n}\n\nexport default getTrackSources;\n","import arrayFindIndex from 'array-find-index';\n\nfunction findTrackIndexByUrl(playlist, url) {\n  return arrayFindIndex(playlist, track => {\n    if (track.sources) {\n      return arrayFindIndex(track.sources, source => source.src === url) !== -1;\n    }\n    return track.url && url === track.url;\n  });\n}\n\nexport default findTrackIndexByUrl;\n","import getTrackSources from './getTrackSources';\n\n// collapses playlist into flat list containing\n// the first source url for each track\nfunction getSourceList(playlist) {\n  return (playlist || []).map((_, i) => getTrackSources(playlist, i)[0].src);\n}\n\nexport default getSourceList;\n","function getTimeRangesArray(timeRangesObj) {\n  const timeRangesArray = Array(timeRangesObj.length);\n  for (let i = 0; i < timeRangesObj.length; i++) {\n    timeRangesArray[i] = {\n      start: timeRangesObj.start(i),\n      end: timeRangesObj.end(i)\n    };\n  }\n  return timeRangesArray;\n}\n\nexport default getTimeRangesArray;\n","function getRepeatStrategy(loop, cycle) {\n  if (loop) {\n    return 'track';\n  }\n  if (cycle) {\n    return 'playlist';\n  }\n  return 'none';\n}\n\nexport default getRepeatStrategy;\n","function convertToNumberWithinIntervalBounds(number, min, max) {\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n  return Math.max(min, Math.min(number, max));\n}\n\nexport default convertToNumberWithinIntervalBounds;\n","function streamVideoElementToCanvas(videoElement, canvas, callback) {\n  const ctx = canvas.getContext('2d');\n  let requestId = null;\n  let widthSet = null;\n  let heightSet = null;\n  let placeholderImage = null;\n\n  requestId = requestAnimationFrame(streamToCanvas);\n\n  return {\n    endStream() {\n      cancelAnimationFrame(requestId);\n    },\n    setCanvasSize(width, height) {\n      widthSet = width || null;\n      heightSet = height || null;\n    },\n    setPlaceholderImage(img) {\n      placeholderImage = img || null;\n    }\n  };\n\n  function streamToCanvas() {\n    const { videoWidth, videoHeight } = videoElement;\n\n    // we want to draw the current frame image from the video element\n    let imageElement = videoElement;\n    let imageWidth = videoWidth;\n    let imageHeight = videoHeight;\n    let targetWidth = videoWidth;\n    let targetHeight = videoHeight;\n    let isVideo = true;\n\n    // however if there's no video to display (usually means we're playing\n    // media) then we want to display a placeholder image, if available\n    if (!(targetWidth && targetHeight) && placeholderImage) {\n      imageElement = placeholderImage;\n      imageWidth = placeholderImage.naturalWidth;\n      imageHeight = placeholderImage.naturalHeight;\n      targetWidth = placeholderImage.naturalWidth;\n      targetHeight = placeholderImage.naturalHeight;\n      isVideo = false;\n    }\n\n    // figure out what resolution the drawn image should be\n    if (widthSet && heightSet) {\n      targetWidth = widthSet;\n      targetHeight = heightSet;\n    } else if (widthSet) {\n      targetWidth = widthSet;\n      targetHeight = (widthSet / imageWidth) * imageHeight;\n    } else if (heightSet) {\n      targetHeight = heightSet;\n      targetWidth = (heightSet / imageHeight) * imageWidth;\n    }\n\n    // resize the canvas to the draw resolution if it doesn't already match\n    if (canvas.width !== targetWidth || canvas.height !== targetHeight) {\n      canvas.width = targetWidth;\n      canvas.height = targetHeight;\n    }\n\n    // draw\n    ctx.drawImage(imageElement, 0, 0, targetWidth, targetHeight);\n\n    // let the callback handle any post-processing\n    if (callback) {\n      callback(ctx, isVideo);\n    }\n\n    requestId = requestAnimationFrame(streamToCanvas);\n  }\n}\n\nexport default streamVideoElementToCanvas;\n","import React, { Component, Fragment, createElement } from 'react';\nimport PropTypes from 'prop-types';\nimport arrayFindIndex from 'array-find-index';\n\nimport PlayerContext from './PlayerContext';\nimport GroupContext from './GroupContext';\nimport * as PlayerPropTypes from './PlayerPropTypes';\nimport createCustomMediaElement from './factories/createCustomMediaElement';\nimport ShuffleManager from './utils/ShuffleManager';\nimport { getStateSnapshot, restoreStateFromSnapshot } from './utils/snapshot';\nimport getSourceList from './utils/getSourceList';\nimport getTrackSources from './utils/getTrackSources';\nimport getTimeRangesArray from './utils/getTimeRangesArray';\nimport findTrackIndexByUrl from './utils/findTrackIndexByUrl';\nimport isPlaylistValid from './utils/isPlaylistValid';\nimport getRepeatStrategy from './utils/getRepeatStrategy';\nimport convertToNumberWithinIntervalBounds from './utils/convertToNumberWithinIntervalBounds';\nimport streamVideoElementToCanvas from './utils/streamVideoElementToCanvas';\nimport { logError, logWarning } from './utils/console';\nimport { repeatStrategyOptions } from './constants';\n\nfunction playErrorHandler(err) {\n  logError(err);\n  if (err.name === 'NotAllowedError') {\n    const warningMessage =\n      'Media playback failed at ' +\n      new Date().toLocaleTimeString() +\n      '! (Perhaps autoplay is disabled in this browser.)';\n    logWarning(warningMessage);\n  }\n}\n\n// Existing Media Session API implementations have default handlers\n// for play/pause, and may yield unexpected behavior if custom\n// play/pause handlers are defined - so let's leave them be.\nconst supportableMediaSessionActions = [\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n];\n\n// media element readyState\nconst HAVE_NOTHING = 0;\n\nconst defaultState = {\n  // indicates whether media player should be paused\n  paused: true,\n  // elapsed time for active track, in seconds\n  currentTime: 0,\n  // The most recent targeted time, in seconds, for seek preview\n  seekPreviewTime: 0,\n  /* true if the user is currently dragging the mouse\n   * to seek a new track position\n   */\n  seekInProgress: false,\n  /* true if media was playing when seek previewing began,\n   * it was paused, and it should be resumed on seek\n   * complete\n   */\n  awaitingResumeOnSeekComplete: false,\n  // the duration in seconds of the loaded track\n  duration: 0,\n  // array describing the buffered ranges in the loaded track\n  bufferedRanges: [],\n  // array describing the already-played ranges in the loaded track\n  playedRanges: [],\n  // array describing the seekable ranges in the loaded track\n  seekableRanges: [],\n  // true if the media is currently stalled pending data buffering\n  stalled: false,\n  // true if the active track should play on the next componentDidUpdate\n  awaitingPlay: false\n};\n\n// assumes playlist is valid\nfunction getGoToTrackState(prevState, index, shouldPlay = true) {\n  const isNewTrack = prevState.activeTrackIndex !== index;\n  return {\n    activeTrackIndex: index,\n    trackLoading: isNewTrack,\n    currentTime: 0,\n    loop: isNewTrack ? false : prevState.loop,\n    awaitingPlay: Boolean(shouldPlay),\n    paused: !shouldPlay\n  };\n}\n\n/**\n * Wraps an area which shares a common [`playerContext`](#playercontext)\n */\nexport class PlayerContextProvider extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      ...defaultState,\n      // index matching requested track (whether track has loaded or not)\n      activeTrackIndex: convertToNumberWithinIntervalBounds(\n        props.startingTrackIndex,\n        0\n      ),\n      // whether we're waiting on loading metadata for the active track\n      trackLoading: isPlaylistValid(props.playlist),\n      // the current timestamp on the active track in seconds\n      currentTime: convertToNumberWithinIntervalBounds(props.startingTime, 0),\n      // the latest volume of the media, between 0 and 1.\n      volume: convertToNumberWithinIntervalBounds(props.defaultVolume, 0, 1),\n      // true if the media has been muted\n      muted: props.defaultMuted,\n      // whether to loop the active track\n      loop: props.defaultRepeatStrategy === 'track',\n      // true if playlist should continue at start after completion\n      cycle: props.defaultRepeatStrategy === 'playlist',\n      // whether to randomly pick next track from playlist after one finishes\n      shuffle: props.defaultShuffle,\n      // Rate at which media should be played. 1.0 is normal speed.\n      playbackRate: props.defaultPlaybackRate,\n      // true if user is currently dragging mouse to change the volume\n      setVolumeInProgress: false,\n      // initialize awaitingPlay from autoplay prop\n      awaitingPlay: props.autoplay && isPlaylistValid(props.playlist),\n      // playlist prop copied to state (for getDerivedStateFromProps)\n      __playlist__: props.playlist,\n      // load overrides from previously-captured state snapshot\n      ...(props.initialStateSnapshot\n        ? restoreStateFromSnapshot(props.initialStateSnapshot, props)\n        : {})\n    };\n\n    // volume at last time we were unmuted and not actively setting volume\n    this.lastStableVolume = this.state.volume;\n\n    // used to keep track of play history when we are shuffling\n    this.shuffler = new ShuffleManager(getSourceList(props.playlist), {\n      allowBackShuffle: props.allowBackShuffle\n    });\n\n    // html media element used for playback\n    this.media = null;\n\n    this.setMediaElementRef = this.setMediaElementRef.bind(this);\n\n    // bind callback methods to pass to descendant elements\n    this.togglePause = this.togglePause.bind(this);\n    this.selectTrackIndex = this.selectTrackIndex.bind(this);\n    this.forwardSkip = this.forwardSkip.bind(this);\n    this.backSkip = this.backSkip.bind(this);\n    this.seekPreview = this.seekPreview.bind(this);\n    this.seekComplete = this.seekComplete.bind(this);\n    this.setVolume = this.setVolume.bind(this);\n    this.setVolumeComplete = this.setVolumeComplete.bind(this);\n    this.toggleMuted = this.toggleMuted.bind(this);\n    this.toggleShuffle = this.toggleShuffle.bind(this);\n    this.setRepeatStrategy = this.setRepeatStrategy.bind(this);\n    this.setPlaybackRate = this.setPlaybackRate.bind(this);\n    this.pipeVideoStreamToCanvas = this.pipeVideoStreamToCanvas.bind(this);\n\n    // bind media event handlers\n    this.handleMediaPlay = this.handleMediaPlay.bind(this);\n    this.handleMediaPause = this.handleMediaPause.bind(this);\n    this.handleMediaSrcrequest = this.handleMediaSrcrequest.bind(this);\n    this.handleMediaEnded = this.handleMediaEnded.bind(this);\n    this.handleMediaStalled = this.handleMediaStalled.bind(this);\n    this.handleMediaCanplaythrough = this.handleMediaCanplaythrough.bind(this);\n    this.handleMediaTimeupdate = this.handleMediaTimeupdate.bind(this);\n    this.handleMediaLoadedmetadata = this.handleMediaLoadedmetadata.bind(this);\n    this.handleMediaVolumechange = this.handleMediaVolumechange.bind(this);\n    this.handleMediaDurationchange = this.handleMediaDurationchange.bind(this);\n    this.handleMediaProgress = this.handleMediaProgress.bind(this);\n    this.handleMediaLoopchange = this.handleMediaLoopchange.bind(this);\n    this.handleMediaRatechange = this.handleMediaRatechange.bind(this);\n  }\n\n  componentDidMount() {\n    const media = (this.media = createCustomMediaElement(this.media));\n\n    // initialize media properties\n    if (media.readyState !== HAVE_NOTHING) {\n      // we only set the currentTime now if we're beyond the\n      // HAVE_NOTHING readyState. Otherwise we'll let this get\n      // set when the loadedmetadata event fires. This avoids\n      // an issue where some browsers ignore or delay currentTime\n      // updates when in the HAVE_NOTHING state.\n      media.currentTime = this.state.currentTime;\n    }\n    media.volume = this.state.volume;\n    media.muted = this.state.muted;\n    media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n    media.playbackRate = this.state.playbackRate;\n\n    // add special event listeners on the media element\n    media.addEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.addEventListener('loopchange', this.handleMediaLoopchange);\n\n    if (this.state.awaitingPlay) {\n      this.setState({\n        awaitingPlay: false\n      });\n      this.delayTimeout = setTimeout(() => {\n        this.togglePause(false);\n      }, this.props.autoplayDelayInSeconds * 1000);\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const newPlaylist = nextProps.playlist;\n\n    if (newPlaylist === prevState.__playlist__) {\n      // reference comparison is equal so we'll\n      // assume the playlist is unchanged.\n      return null;\n    }\n\n    const baseNewState = {\n      __playlist__: newPlaylist\n    };\n\n    // check if the new playlist is invalid\n    if (!isPlaylistValid(newPlaylist)) {\n      return {\n        ...defaultState,\n        ...baseNewState,\n        activeTrackIndex: 0,\n        trackLoading: false\n      };\n    }\n\n    // check if the activeTrackIndex doesn't need to be updated\n    const prevSources = getTrackSources(\n      prevState.__playlist__,\n      prevState.activeTrackIndex\n    );\n    // the sources if we stay on the same track index\n    const currentSources = getTrackSources(\n      newPlaylist,\n      prevState.activeTrackIndex\n    );\n    // non-comprehensive but probably accurate check\n    if (prevSources[0].src === currentSources[0].src) {\n      // our active track index already matches\n      return baseNewState;\n    }\n\n    /* if the track we're already playing is in the new playlist, update the\n     * activeTrackIndex.\n     */\n    const newTrackIndex = findTrackIndexByUrl(newPlaylist, prevSources[0].src);\n    if (newTrackIndex !== -1) {\n      return {\n        ...baseNewState,\n        activeTrackIndex: newTrackIndex\n      };\n    }\n\n    // if not, then load the first track in the new playlist, and pause.\n    return {\n      ...baseNewState,\n      ...getGoToTrackState(prevState, 0, false)\n    };\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n\n    this.shuffler.setList(getSourceList(this.props.playlist));\n    this.shuffler.setOptions({\n      allowBackShuffle: this.props.allowBackShuffle\n    });\n\n    const prevSources = getTrackSources(\n      prevProps.playlist,\n      prevState.activeTrackIndex\n    );\n    const newSources = getTrackSources(\n      this.props.playlist,\n      this.state.activeTrackIndex\n    );\n    if (prevSources[0].src !== newSources[0].src) {\n      // cancel playback and re-scan current sources\n      this.media.load();\n\n      if (!this.state.shuffle) {\n        // after toggling off shuffle, we defer clearing the shuffle\n        // history until we actually change tracks - if the user quickly\n        // toggles  shuffle off then back on again, we don't want to have\n        // lost our history.\n        this.shuffler.clear();\n      }\n    }\n\n    if (prevProps !== this.props && !this.media.paused) {\n      // update running media session based on new props\n      this.stealMediaSession();\n    }\n\n    if (this.state.awaitingPlay) {\n      this.setState({\n        awaitingPlay: false\n      });\n      // media.currentSrc is updated asynchronously so we should\n      // play async to avoid weird intermediate state issues\n      setTimeout(() => {\n        this.togglePause(false);\n      });\n    }\n\n    clearTimeout(this.snapshotUpdateTimeout);\n    this.snapshotUpdateTimeout = setTimeout(() => {\n      if (this.props.onStateSnapshot) {\n        this.props.onStateSnapshot(getStateSnapshot(this.state));\n      }\n    }, 100);\n  }\n\n  componentWillUnmount() {\n    const { media } = this;\n    // remove special event listeners on the media element\n    media.removeEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.removeEventListener('loopchange', this.handleMediaLoopchange);\n\n    clearTimeout(this.gapLengthTimeout);\n    clearTimeout(this.delayTimeout);\n  }\n\n  setMediaElementRef(ref) {\n    this.media = ref;\n    if (typeof this.props.mediaElementRef === 'function') {\n      this.props.mediaElementRef(ref);\n    }\n  }\n\n  stealMediaSession() {\n    if (\n      // eslint-disable-next-line no-undef\n      !(window.MediaSession && navigator.mediaSession instanceof MediaSession)\n    ) {\n      return;\n    }\n    // eslint-disable-next-line no-undef\n    navigator.mediaSession.metadata = new MediaMetadata(\n      this.props.playlist[this.state.activeTrackIndex]\n    );\n    supportableMediaSessionActions\n      .map(action => {\n        if (this.props.supportedMediaSessionActions.indexOf(action) === -1) {\n          return null;\n        }\n        const seekLength = this.props.mediaSessionSeekLengthInSeconds;\n        switch (action) {\n          case 'play':\n            return this.togglePause.bind(this, false);\n          case 'pause':\n            return this.togglePause.bind(this, true);\n          case 'previoustrack':\n            return this.backSkip;\n          case 'nexttrack':\n            return this.forwardSkip;\n          case 'seekbackward':\n            return () => (this.media.currentTime -= seekLength);\n          case 'seekforward':\n            return () => (this.media.currentTime += seekLength);\n          default:\n            return undefined;\n        }\n      })\n      .forEach((handler, i) => {\n        navigator.mediaSession.setActionHandler(\n          supportableMediaSessionActions[i],\n          handler\n        );\n      });\n  }\n\n  pipeVideoStreamToCanvas(canvas, callback) {\n    return streamVideoElementToCanvas(this.media, canvas, callback);\n  }\n\n  handleMediaPlay() {\n    this.setState(state => (state.paused === false ? null : { paused: false }));\n    this.stealMediaSession();\n  }\n\n  handleMediaPause() {\n    this.setState(state => (state.paused === true ? null : { paused: true }));\n  }\n\n  handleMediaSrcrequest(e) {\n    const { playlist } = this.props;\n    const sources = getTrackSources(playlist, this.state.activeTrackIndex);\n    if (arrayFindIndex(sources, s => s.src === e.srcRequested) !== -1) {\n      // we're good! nothing to update.\n      return;\n    }\n    // looks like 'src' was set from outside our component.\n    // let's see if we can use it.\n    const newTrackIndex = findTrackIndexByUrl(playlist, e.srcRequested);\n    if (newTrackIndex === -1) {\n      logError(\n        `Source '${e.srcRequested}' does not exist in the loaded playlist. ` +\n          `Make sure you've updated the 'playlist' prop to ` +\n          `PlayerContextProvider before you select this track!`\n      );\n      return;\n    }\n    this.selectTrackIndex(newTrackIndex);\n  }\n\n  handleMediaEnded() {\n    if (this.state.seekInProgress) {\n      // nothing to do if we're in the middle of a seek\n      // (this can happen if we're in seekMode: immediate)\n      return;\n    }\n    clearTimeout(this.gapLengthTimeout);\n    const { playlist, loadFirstTrackOnPlaylistComplete } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    const { cycle, activeTrackIndex } = this.state;\n    if (!cycle && activeTrackIndex + 1 >= playlist.length) {\n      if (loadFirstTrackOnPlaylistComplete) {\n        this.goToTrack(0, false);\n      }\n      return;\n    }\n    this.gapLengthTimeout = setTimeout(\n      this.forwardSkip,\n      this.props.gapLengthInSeconds * 1000\n    );\n  }\n\n  handleMediaStalled() {\n    this.setState(state => (state.stalled === true ? null : { stalled: true }));\n  }\n\n  handleMediaCanplaythrough() {\n    this.setState(\n      state => (state.stalled === false ? null : { stalled: false })\n    );\n  }\n\n  handleMediaTimeupdate() {\n    const { currentTime, played } = this.media;\n    this.setState({\n      currentTime,\n      playedRanges: getTimeRangesArray(played)\n    });\n  }\n\n  handleMediaLoadedmetadata() {\n    if (this.media.currentTime !== this.state.currentTime) {\n      this.media.currentTime = this.state.currentTime;\n    }\n    this.setState(\n      state => (state.trackLoading === false ? null : { trackLoading: false })\n    );\n  }\n\n  handleMediaVolumechange() {\n    const { volume, muted } = this.media;\n    this.setState({ volume, muted });\n  }\n\n  handleMediaDurationchange() {\n    const { duration } = this.media;\n    this.setState({ duration });\n  }\n\n  handleMediaProgress() {\n    this.setState({\n      bufferedRanges: getTimeRangesArray(this.media.buffered),\n      seekableRanges: getTimeRangesArray(this.media.seekable)\n    });\n  }\n\n  handleMediaLoopchange() {\n    const { loop } = this.media;\n    this.setState(state => (state.loop === loop ? null : { loop }));\n  }\n\n  handleMediaRatechange() {\n    const { playbackRate } = this.media;\n    this.setState(\n      state => (state.playbackRate === playbackRate ? null : { playbackRate })\n    );\n  }\n\n  togglePause(value) {\n    clearTimeout(this.delayTimeout);\n    const pause = typeof value === 'boolean' ? value : !this.state.paused;\n    if (pause) {\n      this.media.pause();\n      return;\n    }\n    if (!this.media.currentSrc) {\n      return;\n    }\n    try {\n      const playPromise = this.media.play();\n      if (playPromise && typeof playPromise.catch === 'function') {\n        playPromise\n          .catch(err => {\n            // AbortError is pretty much always called because we're skipping\n            // tracks quickly or hitting pause before a track has a chance to\n            // play. It's pretty safe to just ignore these error messages.\n            if (err.name !== 'AbortError') {\n              return Promise.reject(err);\n            }\n          })\n          .catch(playErrorHandler);\n      }\n    } catch (err) {\n      playErrorHandler(err);\n    }\n  }\n\n  // assumes playlist is valid - don't call without checking\n  goToTrack(index, shouldPlay = true) {\n    clearTimeout(this.delayTimeout);\n    this.setState(state => getGoToTrackState(state, index, shouldPlay));\n  }\n\n  selectTrackIndex(index) {\n    const { playlist } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    if (index < 0 || index > playlist.length) {\n      logWarning(`Playlist index ${index} is out of bounds!`);\n      return;\n    }\n    if (this.state.shuffle) {\n      this.shuffler.pickNextItem(index, this.state.activeTrackIndex);\n    }\n    this.goToTrack(index);\n  }\n\n  backSkip() {\n    const { playlist, stayOnBackSkipThreshold } = this.props;\n    const { media } = this;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      media.currentTime >= stayOnBackSkipThreshold ||\n      (!cycle && activeTrackIndex < 1)\n    ) {\n      media.currentTime = 0;\n      return;\n    }\n    let index;\n    if (shuffle) {\n      const previousItem = this.shuffler.findPreviousItem(activeTrackIndex);\n      if (previousItem === undefined) {\n        // if we aren't allowing backShuffle then we'll hit a stopping point.\n        media.currentTime = 0;\n        return;\n      }\n      index = findTrackIndexByUrl(playlist, previousItem);\n    } else {\n      index = activeTrackIndex - 1;\n      if (index < 0) {\n        index = playlist.length - 1;\n      }\n    }\n    this.goToTrack(index);\n  }\n\n  forwardSkip() {\n    const { playlist } = this.props;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      (!cycle && activeTrackIndex + 1 >= playlist.length)\n    ) {\n      return;\n    }\n    let index;\n    if (shuffle) {\n      index = findTrackIndexByUrl(\n        playlist,\n        this.shuffler.findNextItem(activeTrackIndex)\n      );\n    } else {\n      index = activeTrackIndex + 1;\n      if (index >= playlist.length) {\n        index = 0;\n      }\n    }\n    this.goToTrack(index);\n  }\n\n  seekPreview(targetTime) {\n    if (!isPlaylistValid(this.props.playlist)) {\n      return;\n    }\n    const baseStateUpdate = {\n      seekPreviewTime: targetTime,\n      seekInProgress: true\n    };\n    switch (this.props.seekMode) {\n      case 'paused':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true\n        }));\n        this.media.currentTime = targetTime;\n        if (!this.state.paused) {\n          this.togglePause(true);\n        }\n        break;\n      case 'immediate':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true\n        }));\n        this.media.currentTime = targetTime;\n        if (this.state.awaitingResumeOnSeekComplete && !this.media.ended) {\n          // if we earlier encountered an 'ended' state,\n          // un-pausing becomes necessary to resume playback\n          this.togglePause(false);\n        }\n        break;\n      case 'onrelease':\n        this.setState(baseStateUpdate);\n        break;\n    }\n  }\n\n  seekComplete() {\n    const { seekPreviewTime, awaitingResumeOnSeekComplete } = this.state;\n    const baseStateUpdate = {\n      seekInProgress: false,\n      awaitingResumeOnSeekComplete: false\n    };\n    if (isNaN(seekPreviewTime)) {\n      this.setState(baseStateUpdate);\n      return;\n    }\n    this.setState({\n      ...baseStateUpdate,\n      /* we'll update currentTime on the media listener hook anyway,\n       * but that might not happen for a bit... so the optimistic update\n       * helps us avoid the progress bar jumping around and confusing the user.\n       * https://github.com/benwiley4000/cassette/issues/209\n       */\n      currentTime: seekPreviewTime\n    });\n    this.media.currentTime = seekPreviewTime;\n    if (awaitingResumeOnSeekComplete) {\n      if (this.media.ended) {\n        this.forwardSkip();\n      } else {\n        this.togglePause(false);\n      }\n    }\n  }\n\n  setVolume(volume) {\n    if (!this.state.setVolumeInProgress) {\n      this.setState({\n        setVolumeInProgress: true\n      });\n    }\n    const volumeInBounds = convertToNumberWithinIntervalBounds(volume, 0, 1);\n    this.media.muted = volumeInBounds === 0 ? true : false;\n    this.media.volume = volumeInBounds;\n  }\n\n  setVolumeComplete() {\n    this.setState({\n      setVolumeInProgress: false\n    });\n    if (!this.media.muted) {\n      this.lastStableVolume = this.media.volume;\n    }\n  }\n\n  toggleMuted(value) {\n    const muted = typeof value === 'boolean' ? value : !this.state.muted;\n    this.media.muted = muted;\n    if (!muted) {\n      this.media.volume = this.lastStableVolume;\n    }\n  }\n\n  toggleShuffle(value) {\n    const shuffle = typeof value === 'boolean' ? value : !this.state.shuffle;\n    this.setState({ shuffle });\n  }\n\n  setRepeatStrategy(repeatStrategy) {\n    if (repeatStrategyOptions.indexOf(repeatStrategy) === -1) {\n      logWarning(\n        'repeatStrategy \"' +\n          repeatStrategy +\n          '\" is not one of: ' +\n          repeatStrategyOptions.split(', ') +\n          '.'\n      );\n      return;\n    }\n    this.setState(() => {\n      switch (repeatStrategy) {\n        case 'track':\n          return {\n            loop: true\n          };\n        case 'playlist':\n          return {\n            loop: false,\n            cycle: true\n          };\n        case 'none':\n          return {\n            loop: false,\n            cycle: false\n          };\n        default:\n          return null;\n      }\n    });\n  }\n\n  setPlaybackRate(rate) {\n    this.media.playbackRate = rate;\n  }\n\n  getControlProps() {\n    const { props, state } = this;\n    const playerContext = {\n      playlist: props.playlist,\n      activeTrackIndex: state.activeTrackIndex,\n      trackLoading: state.trackLoading,\n      paused: state.paused,\n      currentTime: state.currentTime,\n      seekPreviewTime: state.seekPreviewTime,\n      seekInProgress: state.seekInProgress,\n      awaitingResumeOnSeekComplete: state.awaitingResumeOnSeekComplete,\n      duration: state.duration,\n      bufferedRanges: state.bufferedRanges,\n      playedRanges: state.playedRanges,\n      seekableRanges: state.seekableRanges,\n      volume: state.volume,\n      muted: state.muted,\n      shuffle: state.shuffle,\n      stalled: state.stalled,\n      playbackRate: state.playbackRate,\n      setVolumeInProgress: state.setVolumeInProgress,\n      repeatStrategy: getRepeatStrategy(state.loop, state.cycle),\n      pipeVideoStreamToCanvas: this.pipeVideoStreamToCanvas,\n      onTogglePause: this.togglePause,\n      onSelectTrackIndex: this.selectTrackIndex,\n      onBackSkip: this.backSkip,\n      onForwardSkip: this.forwardSkip,\n      onSeekPreview: this.seekPreview,\n      onSeekComplete: this.seekComplete,\n      onSetVolume: this.setVolume,\n      onSetVolumeComplete: this.setVolumeComplete,\n      onToggleMuted: this.toggleMuted,\n      onToggleShuffle: this.toggleShuffle,\n      onSetRepeatStrategy: this.setRepeatStrategy,\n      onSetPlaybackRate: this.setPlaybackRate\n    };\n    if (this.playerContext) {\n      // only update this.playerContext if something has changed\n      for (const key of Object.keys(this.playerContext)) {\n        if (playerContext[key] !== this.playerContext[key]) {\n          this.playerContext = playerContext;\n          break;\n        }\n      }\n    } else {\n      // first time - nothing to compare\n      this.playerContext = playerContext;\n    }\n    return this.playerContext;\n  }\n\n  render() {\n    const sources = getTrackSources(\n      this.props.playlist,\n      this.state.activeTrackIndex\n    );\n    const playerContext = this.getControlProps();\n    return (\n      <Fragment>\n        <video\n          hidden\n          ref={this.setMediaElementRef}\n          crossOrigin={this.props.crossOrigin}\n          preload=\"metadata\"\n          loop={this.state.loop}\n          onPlay={this.handleMediaPlay}\n          onPause={this.handleMediaPause}\n          onEnded={this.handleMediaEnded}\n          onStalled={this.handleMediaStalled}\n          onCanPlayThrough={this.handleMediaCanplaythrough}\n          onTimeUpdate={this.handleMediaTimeupdate}\n          onLoadedMetadata={this.handleMediaLoadedmetadata}\n          onVolumeChange={this.handleMediaVolumechange}\n          onDurationChange={this.handleMediaDurationchange}\n          onProgress={this.handleMediaProgress}\n          onRateChange={this.handleMediaRatechange}\n        >\n          {sources.map(source => (\n            <source key={source.src} src={source.src} type={source.type} />\n          ))}\n        </video>\n        <PlayerContext.Provider value={playerContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(playerContext)\n            : this.props.children}\n        </PlayerContext.Provider>\n      </Fragment>\n    );\n  }\n}\n\nPlayerContextProvider.propTypes = {\n  playlist: PropTypes.arrayOf(PlayerPropTypes.track.isRequired).isRequired,\n  autoplay: PropTypes.bool.isRequired,\n  autoplayDelayInSeconds: PropTypes.number.isRequired,\n  gapLengthInSeconds: PropTypes.number.isRequired,\n  crossOrigin: PlayerPropTypes.crossOriginAttribute,\n  defaultVolume: PropTypes.number.isRequired,\n  defaultMuted: PropTypes.bool,\n  defaultRepeatStrategy: PlayerPropTypes.repeatStrategy.isRequired,\n  defaultShuffle: PropTypes.bool,\n  defaultPlaybackRate: PropTypes.number.isRequired,\n  startingTime: PropTypes.number.isRequired,\n  startingTrackIndex: PropTypes.number.isRequired,\n  loadFirstTrackOnPlaylistComplete: PropTypes.bool,\n  seekMode: PlayerPropTypes.seekMode.isRequired,\n  maintainPlaybackRate: PropTypes.bool.isRequired,\n  allowBackShuffle: PropTypes.bool,\n  stayOnBackSkipThreshold: PropTypes.number.isRequired,\n  supportedMediaSessionActions: PropTypes.arrayOf(\n    PlayerPropTypes.mediaSessionAction.isRequired\n  ).isRequired,\n  mediaSessionSeekLengthInSeconds: PropTypes.number.isRequired,\n  mediaElementRef: PropTypes.func,\n  initialStateSnapshot: PropTypes.shape({\n    __unstable__: PropTypes.object.isRequired\n  }),\n  onStateSnapshot: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nPlayerContextProvider.defaultProps = {\n  autoplay: false,\n  autoplayDelayInSeconds: 0,\n  gapLengthInSeconds: 0,\n  defaultVolume: 1,\n  defaultMuted: false,\n  defaultRepeatStrategy: 'playlist',\n  defaultShuffle: false,\n  defaultPlaybackRate: 1,\n  startingTime: 0,\n  startingTrackIndex: 0,\n  loadFirstTrackOnPlaylistComplete: true,\n  seekMode: 'immediate',\n  maintainPlaybackRate: false,\n  allowBackShuffle: false,\n  stayOnBackSkipThreshold: 5,\n  supportedMediaSessionActions: ['play', 'pause', 'previoustrack', 'nexttrack'],\n  mediaSessionSeekLengthInSeconds: 10\n};\n\nexport class PlayerContextGroupMember extends Component {\n  componentDidMount() {\n    this.props.groupContext.registerMediaElement(this.mediaElement);\n  }\n\n  componentWillUnmount() {\n    this.props.groupContext.unregisterMediaElement(this.mediaElement);\n  }\n\n  render() {\n    const { groupContext, props } = this.props;\n    const { mediaElementRef, ...rest } = props;\n    return (\n      <PlayerContextProvider\n        {...groupContext.groupProps}\n        {...rest}\n        mediaElementRef={ref => {\n          if (mediaElementRef) {\n            mediaElementRef(ref);\n          }\n          this.mediaElement = ref;\n        }}\n      />\n    );\n  }\n}\n\nPlayerContextGroupMember.propTypes = {\n  groupContext: PropTypes.shape({\n    groupProps: PropTypes.object.isRequired,\n    registerMediaElement: PropTypes.func.isRequired,\n    unregisterMediaElement: PropTypes.func.isRequired\n  }).isRequired\n};\n\nfunction PlayerContextGroupConsumer(props) {\n  return (\n    <GroupContext.Consumer>\n      {groupContext => {\n        if (!groupContext) {\n          return createElement(PlayerContextProvider, props);\n        }\n        return createElement(PlayerContextGroupMember, {\n          groupContext,\n          props\n        });\n      }}\n    </GroupContext.Consumer>\n  );\n}\n\nexport default PlayerContextGroupConsumer;\n","import isPlaylistValid from './isPlaylistValid';\nimport getTrackSources from './getTrackSources';\nimport findTrackIndexByUrl from './findTrackIndexByUrl';\n\nexport function getStateSnapshot(state) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    __playlist__\n  } = state;\n  return {\n    __unstable__: {\n      paused,\n      currentTime,\n      activeTrackIndex,\n      volume,\n      muted,\n      loop,\n      cycle,\n      shuffle,\n      playbackRate,\n      activeTrackSrc: isPlaylistValid(__playlist__)\n        ? getTrackSources(__playlist__, activeTrackIndex)[0].src\n        : null\n    }\n  };\n}\n\nexport function restoreStateFromSnapshot(snapshot, props) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    activeTrackSrc\n  } = snapshot.__unstable__;\n  const restoredStateValues = {};\n  if (isPlaylistValid(props.playlist) && typeof paused === 'boolean') {\n    // using awaitingPlay instead of paused triggers an animation\n    restoredStateValues.awaitingPlay = !paused;\n  }\n  if (typeof volume === 'number' && volume >= 0 && volume <= 1) {\n    restoredStateValues.volume = volume;\n  }\n  if (typeof muted === 'boolean') {\n    restoredStateValues.muted = muted;\n  }\n  if (typeof loop === 'boolean') {\n    restoredStateValues.loop = loop;\n  }\n  if (typeof cycle === 'boolean') {\n    restoredStateValues.cycle = cycle;\n  }\n  if (typeof shuffle === 'boolean') {\n    restoredStateValues.shuffle = shuffle;\n  }\n  if (typeof playbackRate === 'number') {\n    restoredStateValues.playbackRate = playbackRate;\n  }\n  let useCurrentTime = false;\n  if (\n    typeof activeTrackSrc === 'string' &&\n    typeof activeTrackIndex === 'number' &&\n    activeTrackIndex >= 0\n  ) {\n    // let's try staying on the same track index\n    const currentSrc = getTrackSources(props.playlist, activeTrackIndex)[0].src;\n    if (activeTrackSrc === currentSrc) {\n      restoredStateValues.activeTrackIndex = activeTrackIndex;\n      useCurrentTime = true;\n    } else {\n      /* if the track we were playing before is in the new playlist,\n       * update the activeTrackIndex.\n       */\n      const newTrackIndex = findTrackIndexByUrl(props.playlist, activeTrackSrc);\n      if (newTrackIndex !== -1) {\n        restoredStateValues.activeTrackIndex = newTrackIndex;\n        useCurrentTime = true;\n      }\n    }\n  }\n  if (useCurrentTime && typeof currentTime === 'number' && currentTime >= 0) {\n    restoredStateValues.currentTime = currentTime;\n  }\n  return restoredStateValues;\n}\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport GroupContext from './GroupContext';\n\n/**\n * A wrapper which can be used to share configuration among multiple descendant [`PlayerContextProvider`](#playercontextprovider) instances as well as prevent multiple media elements from playing audio simultaneously\n */\nexport class PlayerContextGroup extends Component {\n  constructor(props) {\n    super(props);\n    this.registerMediaElement = this.registerMediaElement.bind(this);\n    this.unregisterMediaElement = this.unregisterMediaElement.bind(this);\n    this.enforceOneMediaSourceOnly = this.enforceOneMediaSourceOnly.bind(this);\n    this.mediaElements = [];\n  }\n\n  registerMediaElement(elem) {\n    this.mediaElements = this.mediaElements.concat(elem);\n    elem.addEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.addEventListener('volumechange', this.enforceOneMediaSourceOnly, true);\n  }\n\n  unregisterMediaElement(elem) {\n    this.mediaElements = this.mediaElements.filter(element => elem !== element);\n    elem.removeEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.removeEventListener(\n      'volumechange',\n      this.enforceOneMediaSourceOnly,\n      true\n    );\n  }\n\n  enforceOneMediaSourceOnly(e) {\n    const mediaElement = e.target;\n    const { paused, muted } = mediaElement;\n    if (paused || muted) {\n      return;\n    }\n    for (const element of this.mediaElements) {\n      if (element !== mediaElement && !element.muted) {\n        element.pause();\n      }\n    }\n  }\n\n  render() {\n    return (\n      <GroupContext.Consumer>\n        {groupContext => {\n          const value = groupContext\n            ? {\n                ...groupContext,\n                groupProps: { ...groupContext.groupProps, ...this.props }\n              }\n            : {\n                groupProps: this.props,\n                registerMediaElement: this.registerMediaElement,\n                unregisterMediaElement: this.unregisterMediaElement\n              };\n          return (\n            <GroupContext.Provider value={value}>\n              {this.props.children}\n            </GroupContext.Provider>\n          );\n        }}\n      </GroupContext.Consumer>\n    );\n  }\n}\n\nPlayerContextGroup.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\nexport default PlayerContextGroup;\n","import { createContext } from 'react';\n\nimport { logWarning } from './utils/console';\n\nconst FullscreenContext = createContext({\n  fullscreen: false,\n  requestFullscreen() {\n    logWarning(\n      'Fullscreen request ignored since there is no ' +\n        'FullscreenContextProvider ancestor.'\n    );\n  },\n  requestExitFullscreen() {\n    logWarning(\n      'Exit fullscreen request ignored since there is no ' +\n        'FullscreenContextProvider ancestor.'\n    );\n  }\n});\nFullscreenContext.displayName = 'FullscreenContext';\n\nexport default FullscreenContext;\n","import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nimport FullscreenContext from './FullscreenContext';\n\nconst fullscreenStyle = {\n  width: '100%',\n  height: '100%'\n};\n\n/**\n * Wraps an area which should be fullscreen-able\n */\nexport class FullscreenContextProvider extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      fullscreen: false\n    };\n    this.requestFullscreen = this.requestFullscreen.bind(this);\n    this.requestExitFullscreen = this.requestExitFullscreen.bind(this);\n    this.handleFullscreenChange = this.handleFullscreenChange.bind(this);\n    this.fullscreenElement = null;\n  }\n\n  componentDidMount() {\n    document.addEventListener('fullscreenchange', this.handleFullscreenChange);\n    document.addEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\n      'fullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  requestFullscreen() {\n    if (!this.props.fullscreenEnabled) {\n      return;\n    }\n    if (this.fullscreenElement.requestFullscreen) {\n      this.fullscreenElement.requestFullscreen();\n    } else if (this.fullscreenElement.webkitRequestFullscreen) {\n      this.fullscreenElement.webkitRequestFullscreen();\n    } else if (this.fullscreenElement.mozRequestFullscreen) {\n      this.fullscreenElement.mozRequestFullScreen();\n    } else if (this.fullscreenElement.msRequestFullscreen) {\n      this.fullscreenElement.msRequestFullscreen();\n    }\n  }\n\n  requestExitFullscreen() {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    } else if (document.webkitCancelFullScreen) {\n      document.webkitCancelFullScreen();\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen();\n    } else if (document.msExitFullscreen) {\n      document.mozExitFullscreen();\n    }\n  }\n\n  handleFullscreenChange() {\n    const documentFullscreenElement =\n      document.fullscreenElement ||\n      document.webkitFullscreenElement ||\n      document.mozFullScreenElement ||\n      document.msFullscreenElement;\n    this.setState({\n      fullscreen: documentFullscreenElement === this.fullscreenElement\n    });\n  }\n\n  getFullscreenContext() {\n    const fullscreenContext = {\n      fullscreen: this.state.fullscreen,\n      requestFullscreen: this.requestFullscreen,\n      requestExitFullscreen: this.requestExitFullscreen\n    };\n    if (\n      this.fullscreenContext &&\n      fullscreenContext.fullscreen === this.fullscreenContext.fullscreen\n    ) {\n      // no change\n      return this.fullscreenContext;\n    }\n    return (this.fullscreenContext = fullscreenContext);\n  }\n\n  render() {\n    const fullscreenContext = this.getFullscreenContext();\n    return (\n      <div\n        ref={elem => (this.fullscreenElement = elem)}\n        style={this.state.fullscreen ? fullscreenStyle : undefined}\n      >\n        <FullscreenContext.Provider value={fullscreenContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(fullscreenContext)\n            : this.props.children}\n        </FullscreenContext.Provider>\n      </div>\n    );\n  }\n}\n\nFullscreenContextProvider.propTypes = {\n  fullscreenEnabled: PropTypes.bool.isRequired,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nFullscreenContextProvider.defaultProps = {\n  fullscreenEnabled: true\n};\n\nexport default FullscreenContextProvider;\n","import React, { createElement } from 'react';\n\nimport PlayerContext from './PlayerContext';\nimport FullscreenContext from './FullscreenContext';\nimport { logWarning } from './utils/console';\n\nfunction playerContextFilter(component, contextPropNames) {\n  const warned = {};\n  const childName = component.displayName || component.name;\n  function PlayerContextFilter(props) {\n    return (\n      <FullscreenContext.Consumer>\n        {fullscreenContext => (\n          <PlayerContext.Consumer>\n            {playerContext => {\n              const childProps = { ...props };\n              for (const propName of contextPropNames) {\n                if (playerContext.hasOwnProperty(propName)) {\n                  childProps[propName] = playerContext[propName];\n                } else if (fullscreenContext.hasOwnProperty(propName)) {\n                  childProps[propName] = fullscreenContext[propName];\n                } else if (!warned[propName]) {\n                  logWarning(\n                    \"Prop '\" +\n                      propName +\n                      \"' for component \" +\n                      childName +\n                      ' not found in playerContext or fullscreenContext.'\n                  );\n                  warned[propName] = true;\n                }\n              }\n              return createElement(component, childProps);\n            }}\n          </PlayerContext.Consumer>\n        )}\n      </FullscreenContext.Consumer>\n    );\n  }\n  if (childName) {\n    PlayerContextFilter.displayName = `PlayerContextFilter(${childName})`;\n  }\n  return PlayerContextFilter;\n}\n\nexport default playerContextFilter;\n","import PlayerContextProvider from './PlayerContextProvider';\nimport PlayerContext from './PlayerContext';\nimport PlayerContextGroup from './PlayerContextGroup';\nimport FullscreenContextProvider from './FullscreenContextProvider';\nimport FullscreenContext from './FullscreenContext';\nimport playerContextFilter from './playerContextFilter';\nimport * as PlayerPropTypes from './PlayerPropTypes';\n\nexport { PlayerContextProvider };\nexport const PlayerContextConsumer = PlayerContext.Consumer;\nexport { PlayerContextGroup };\nexport { FullscreenContextProvider };\nexport const FullscreenContextConsumer = FullscreenContext.Consumer;\nexport { playerContextFilter };\nexport { PlayerPropTypes };\n\n// undocumented exports\nexport * from './utils/console';\nexport {\n  default as convertToNumberWithinIntervalBounds\n} from './utils/convertToNumberWithinIntervalBounds';\nexport { default as isPlaylistValid } from './utils/isPlaylistValid';\nexport { repeatStrategyOptions } from './constants';\n"],"sourceRoot":""}