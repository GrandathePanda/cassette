{"version":3,"sources":["webpack://cassetteCore/webpack/universalModuleDefinition","webpack://cassetteCore/webpack/bootstrap","webpack://cassetteCore/external {\"root\":\"PropTypes\",\"commonjs\":\"prop-types\",\"commonjs2\":\"prop-types\",\"amd\":\"prop-types\"}","webpack://cassetteCore/external {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\"}","webpack://cassetteCore/./node_modules/array-find-index/index.js","webpack://cassetteCore/./src/PlayerContext.js","webpack://cassetteCore/./src/GroupContext.js","webpack://cassetteCore/./src/constants.js","webpack://cassetteCore/./src/utils/console.js","webpack://cassetteCore/./src/PlayerPropTypes.js","webpack://cassetteCore/./src/factories/createCustomMediaElement.js","webpack://cassetteCore/./src/utils/ShuffleManager.js","webpack://cassetteCore/./src/utils/isPlaylistValid.js","webpack://cassetteCore/./src/utils/getTrackSources.js","webpack://cassetteCore/./src/utils/findTrackIndexByUrl.js","webpack://cassetteCore/./src/utils/getSourceList.js","webpack://cassetteCore/./src/utils/getTimeRangesArray.js","webpack://cassetteCore/./src/utils/getRepeatStrategy.js","webpack://cassetteCore/./src/utils/convertToNumberWithinIntervalBounds.js","webpack://cassetteCore/./src/utils/streamVideoElementToCanvas.js","webpack://cassetteCore/./src/PlayerContextProvider.js","webpack://cassetteCore/./src/utils/snapshot.js","webpack://cassetteCore/./src/PlayerContextGroup.js","webpack://cassetteCore/./src/FullscreenContext.js","webpack://cassetteCore/./src/FullscreenContextProvider.js","webpack://cassetteCore/./src/playerContextFilter.js","webpack://cassetteCore/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","arr","predicate","ctx","Array","findIndex","TypeError","list","len","length","PlayerContext","external_root_React_commonjs_react_commonjs2_react_amd_react_","displayName","src_PlayerContext","GroupContext","src_GroupContext","repeatStrategyOptions","log","console","logError","error","logWarning","warn","requiredOnlyUnlessHasProp","propType","altPropName","warnedAboutDefiningBoth","props","propName","componentName","rest","isRequired","Error","controlKeyword","external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default","a","oneOf","control","oneOfType","func","crossOriginAttribute","PlayerPropTypes_repeatStrategy","mediaSource","shape","src","string","type","mediaSessionAction","mediaSessionArtwork","sizes","PlayerPropTypes_track","url","sources","arrayOf","title","artist","album","artwork","meta","progressDirection","seekMode","aspectRatio","prop","undefined","split","some","isNaN","loopchange","srcrequest","factories_createCustomMediaElement","media","document","createElement","MutationObserver","dispatchEvent","Event","observe","attributeFilter","currentSrc","set","e","srcRequested","_goForward","forwardStack","backStack","currentItem","item","push","pop","_findNextItem","allowMore","nextItem","indexOf","_allItemsMatch","Math","floor","random","utils_ShuffleManager","constructor","options","this","_list","_forwardStack","_backStack","_currentItem","_allowBackShuffle","Boolean","allowBackShuffle","findNextItem","currentIndex","setCurrentIndex","findPreviousItem","pickNextItem","index","setList","setOptions","keys","clear","utils_isPlaylistValid","playlist","blankSources","utils_getTrackSources","_playlist$index","utils_findTrackIndexByUrl","array_find_index_default","track","source","utils_getSourceList","map","_","utils_getTimeRangesArray","timeRangesObj","timeRangesArray","start","end","utils_getRepeatStrategy","loop","cycle","utils_convertToNumberWithinIntervalBounds","number","min","max","Infinity","utils_streamVideoElementToCanvas","videoElement","canvas","callback","getContext","requestId","widthSet","heightSet","placeholderImage","requestAnimationFrame","streamToCanvas","videoWidth","videoHeight","imageElement","imageWidth","imageHeight","targetWidth","targetHeight","isVideo","naturalWidth","naturalHeight","width","height","drawImage","endStream","cancelAnimationFrame","setCanvasSize","setPlaceholderImage","img","playErrorHandler","err","warningMessage","Date","toLocaleTimeString","supportableMediaSessionActions","HAVE_NOTHING","defaultState","paused","currentTime","seekPreviewTime","seekInProgress","awaitingResumeOnSeekComplete","duration","bufferedRanges","playedRanges","seekableRanges","stalled","awaitingPlay","getGoToTrackState","prevState","shouldPlay","isNewTrack","activeTrackIndex","trackLoading","PlayerContextProvider_PlayerContextProvider","super","state","_objectSpread","startingTrackIndex","startingTime","volume","defaultVolume","muted","defaultMuted","defaultRepeatStrategy","shuffle","defaultShuffle","playbackRate","defaultPlaybackRate","setVolumeInProgress","autoplay","__playlist__","initialStateSnapshot","snapshot","_snapshot$__unstable_","__unstable__","activeTrackSrc","restoredStateValues","useCurrentTime","newTrackIndex","restoreStateFromSnapshot","lastStableVolume","shuffler","setMediaElementRef","togglePause","selectTrackIndex","forwardSkip","backSkip","seekPreview","seekComplete","setVolume","setVolumeComplete","toggleMuted","toggleShuffle","setRepeatStrategy","setPlaybackRate","pipeVideoStreamToCanvas","handleMediaPlay","handleMediaPause","handleMediaSrcrequest","handleMediaEnded","handleMediaStalled","handleMediaCanplaythrough","handleMediaTimeupdate","handleMediaLoadedmetadata","handleMediaVolumechange","handleMediaDurationchange","handleMediaProgress","handleMediaLoopchange","handleMediaRatechange","componentDidMount","readyState","addEventListener","setState","delayTimeout","setTimeout","autoplayDelayInSeconds","[object Object]","nextProps","newPlaylist","baseNewState","prevSources","currentSources","componentDidUpdate","prevProps","newSources","load","stealMediaSession","clearTimeout","snapshotUpdateTimeout","onStateSnapshot","getStateSnapshot","componentWillUnmount","removeEventListener","gapLengthTimeout","ref","mediaElementRef","MediaSession","navigator","mediaSession","metadata","MediaMetadata","action","supportedMediaSessionActions","seekLength","mediaSessionSeekLengthInSeconds","forEach","handler","setActionHandler","_props","loadFirstTrackOnPlaylistComplete","_state","goToTrack","gapLengthInSeconds","_media","played","_media2","buffered","seekable","pause","playPromise","play","catch","Promise","reject","_props2","stayOnBackSkipThreshold","_state2","previousItem","_state3","targetTime","baseStateUpdate","ended","_state4","volumeInBounds","repeatStrategy","rate","getControlProps","playerContext","onTogglePause","onSelectTrackIndex","onBackSkip","onForwardSkip","onSeekPreview","onSeekComplete","onSetVolume","onSetVolumeComplete","onToggleMuted","onToggleShuffle","onSetRepeatStrategy","onSetPlaybackRate","render","external_root_React_commonjs_react_commonjs2_react_amd_react_default","hidden","crossOrigin","preload","onPlay","onPause","onEnded","onStalled","onCanPlayThrough","onTimeUpdate","onLoadedMetadata","onVolumeChange","onDurationChange","onProgress","onRateChange","Provider","children","propTypes","bool","maintainPlaybackRate","node","defaultProps","PlayerContextProvider_PlayerContextGroupMember","groupContext","registerMediaElement","mediaElement","unregisterMediaElement","_props3","_objectWithoutProperties","_extends","groupProps","src_PlayerContextProvider","Consumer","PlayerContextGroup_PlayerContextGroup","enforceOneMediaSourceOnly","mediaElements","elem","concat","filter","element","target","PlayerContextGroup_objectSpread","src_PlayerContextGroup","FullscreenContext","fullscreen","requestFullscreen","requestExitFullscreen","src_FullscreenContext","fullscreenStyle","FullscreenContextProvider_FullscreenContextProvider","handleFullscreenChange","fullscreenElement","fullscreenEnabled","webkitRequestFullscreen","mozRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","webkitCancelFullScreen","mozCancelFullScreen","msExitFullscreen","mozExitFullscreen","documentFullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","getFullscreenContext","fullscreenContext","style","src_FullscreenContextProvider","src_playerContextFilter","component","contextPropNames","warned","childName","PlayerContextFilter","childProps","playerContextFilter_objectSpread","PlayerContextConsumer","FullscreenContextConsumer"],"mappings":"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","file":"esm/cassette-core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cassetteCore\"] = factory(require(\"prop-types\"), require(\"react\"));\n\telse\n\t\troot[\"cassetteCore\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","'use strict';\nmodule.exports = function (arr, predicate, ctx) {\n\tif (typeof Array.prototype.findIndex === 'function') {\n\t\treturn arr.findIndex(predicate, ctx);\n\t}\n\n\tif (typeof predicate !== 'function') {\n\t\tthrow new TypeError('predicate must be a function');\n\t}\n\n\tvar list = Object(arr);\n\tvar len = list.length;\n\n\tif (len === 0) {\n\t\treturn -1;\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tif (predicate.call(ctx, list[i], i, list)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n};\n","import { createContext } from 'react';\n\nconst PlayerContext = createContext(null);\nPlayerContext.displayName = 'PlayerContext';\n\nexport default PlayerContext;\n","import { createContext } from 'react';\n\nconst GroupContext = createContext(null);\nGroupContext.displayName = 'GroupContext';\n\nexport default GroupContext;\n","export const repeatStrategyOptions = ['none', 'playlist', 'track'];\n","/* eslint-disable no-console */\n\nconst log = console.log.bind(console);\n\nexport const logError = console.error ? console.error.bind(console) : log;\nexport const logWarning = console.warn ? console.warn.bind(console) : log;\n","import PropTypes from 'prop-types';\n\nimport { repeatStrategyOptions } from './constants';\nimport { logWarning } from './utils/console';\n\nfunction requiredOnlyUnlessHasProp(propType, altPropName) {\n  let warnedAboutDefiningBoth = false;\n  function validate(props, propName, componentName, ...rest) {\n    if (propName in props) {\n      if (!warnedAboutDefiningBoth && altPropName in props) {\n        logWarning(\n          `Do not define both the '${propName}' and '${altPropName}' props.`\n        );\n        warnedAboutDefiningBoth = true;\n      }\n      return propType.isRequired(props, propName, componentName, ...rest);\n    }\n    if (!(altPropName in props)) {\n      return new Error(\n        `If the '${altPropName}' prop is not defined, '${propName}' must be.`\n      );\n    }\n  }\n  return validate;\n}\n\nexport const controlKeyword = PropTypes.oneOf([\n  'playpause',\n  'backskip',\n  'forwardskip',\n  'volume',\n  'mute',\n  'repeat',\n  'shuffle',\n  'progress',\n  'progressdisplay',\n  'fullscreen',\n  'spacer'\n]);\n\nexport const control = PropTypes.oneOfType([PropTypes.func, controlKeyword]);\n\nexport const crossOriginAttribute = PropTypes.oneOf([\n  'anonymous',\n  'use-credentials'\n]);\n\nexport const repeatStrategy = PropTypes.oneOf(repeatStrategyOptions);\n\nexport const mediaSource = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired\n});\n\nexport const mediaSessionAction = PropTypes.oneOf([\n  'play',\n  'pause',\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n]);\n\nexport const mediaSessionArtwork = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  sizes: PropTypes.string,\n  type: PropTypes.string\n});\n\nexport const track = PropTypes.shape({\n  url: requiredOnlyUnlessHasProp(PropTypes.string, 'sources'),\n  sources: requiredOnlyUnlessHasProp(\n    PropTypes.arrayOf(mediaSource.isRequired),\n    'url'\n  ),\n  title: PropTypes.string.isRequired,\n  artist: PropTypes.string,\n  album: PropTypes.string,\n  artwork: PropTypes.arrayOf(mediaSessionArtwork.isRequired),\n  meta: PropTypes.object\n});\n\nexport const progressDirection = PropTypes.oneOf([\n  'left',\n  'right',\n  'up',\n  'down'\n]);\n\nexport const seekMode = PropTypes.oneOf(['paused', 'immediate', 'onrelease']);\n\nexport function aspectRatio(props, propName) {\n  const prop = props[propName];\n  if (prop === undefined) {\n    return;\n  }\n  if (\n    typeof prop !== 'string' ||\n    prop.split(':').length !== 2 ||\n    prop.split(':').some(isNaN)\n  ) {\n    return new Error(\n      `The ${propName} prop should be a string of the form 'x:y'. Example: 16:9`\n    );\n  }\n}\n","const loopchange = 'loopchange';\nconst srcrequest = 'srcrequest';\n\nfunction createCustomMediaElement(media = document.createElement('media')) {\n  new MutationObserver(() => {\n    media.dispatchEvent(new Event(loopchange));\n  }).observe(media, {\n    attributeFilter: ['loop']\n  });\n  // Don't let the media src property get modified directly.\n  // Instead, when it does get set, dispatch an event to be\n  // handled in a way that doesn't conflict with the loaded\n  // playlist.\n  Object.defineProperty(media, 'src', {\n    get: () => media.currentSrc,\n    set: src => {\n      const e = new Event(srcrequest);\n      e.srcRequested = src;\n      media.dispatchEvent(e);\n    }\n  });\n  return media;\n}\n\nexport default createCustomMediaElement;\n","/* ShuffleManager\n *\n * Manages navigation throughout a list which is:\n * - Sourced from another provided list\n * - In random order (except to avoid consecutive duplicates)\n * - Extended endlessly on-the-fly, as needed\n * - Able to have future history overwritten by non-random choices\n * - Able to swap source lists and maintain shuffle order for common members\n */\n\nexport class ShuffleManager {\n  constructor(list, options = {}) {\n    this._list = list;\n    this._forwardStack = [];\n    this._backStack = [];\n    this._currentItem = undefined;\n\n    this._allowBackShuffle = Boolean(options.allowBackShuffle);\n  }\n\n  findNextItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._forwardStack,\n      this._backStack,\n      this._currentItem,\n      true\n    );\n    return this._currentItem;\n  }\n\n  findPreviousItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._backStack,\n      this._forwardStack,\n      this._currentItem,\n      this._allowBackShuffle\n    );\n    return this._currentItem;\n  }\n\n  pickNextItem(index, currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    if (this._list[index] === undefined) {\n      return undefined;\n    }\n    if (this._currentItem !== undefined) {\n      this._backStack.push(this._currentItem);\n    }\n    this._forwardStack.length = 0;\n    this._currentItem = this._list[index];\n    return this._currentItem;\n  }\n\n  setList(list) {\n    this._list = list;\n  }\n\n  setOptions(options) {\n    for (const o of Object.keys(options)) {\n      switch (o) {\n        case 'allowBackShuffle':\n          this[`_${o}`] = Boolean(options[o]);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  setCurrentIndex(currentIndex) {\n    const item = this._list[currentIndex];\n    if (this._currentItem !== item) {\n      this.clear();\n      this._currentItem = item;\n    }\n  }\n\n  clear() {\n    this._forwardStack.length = 0;\n    this._backStack.length = 0;\n    this._currentItem = undefined;\n  }\n}\n\nfunction _goForward(n, forwardStack, backStack, currentItem) {\n  let item = currentItem;\n  for (let i = 0; i < n; i++) {\n    if (!forwardStack.length) {\n      // rollback before erroring (note stack reversal)\n      _goForward(i, backStack, forwardStack, item);\n      throw `Moving ${n} places was not possible!`;\n    }\n    backStack.push(item);\n    item = forwardStack.pop();\n  }\n  return item;\n}\n\nfunction _allItemsMatch(list, item) {\n  if (!list.length) {\n    return false;\n  }\n  for (let i = 0; i < list.length; i++) {\n    if (item !== list[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction _findNextItem(list, forwardStack, backStack, currentItem, allowMore) {\n  let item = currentItem;\n  if (!list.length) {\n    return undefined;\n  }\n  for (let i = 1; i <= forwardStack.length; i++) {\n    if (list.indexOf(forwardStack[forwardStack.length - i]) !== -1) {\n      return _goForward(i, forwardStack, backStack, item);\n    }\n  }\n  if (!allowMore) {\n    return undefined;\n  }\n  if (_allItemsMatch(list, item)) {\n    // we can serve this as our \"next\" item but we\n    // won't modify our history since it's the same.\n    return item;\n  }\n  let nextItem;\n  do {\n    nextItem = list[Math.floor(Math.random() * list.length)];\n  } while (item === nextItem || nextItem === undefined);\n  // if we're skipping items that aren't in our current list we may\n  // have some items in our forwardStack - make sure we move to the front.\n  item = _goForward(forwardStack.length, forwardStack, backStack, item);\n  if (item !== undefined) {\n    backStack.push(item);\n  }\n  return nextItem;\n}\n\nexport default ShuffleManager;\n","function isPlaylistValid(playlist) {\n  return Boolean(playlist && playlist.length);\n}\n\nexport default isPlaylistValid;\n","import isPlaylistValid from './isPlaylistValid';\n\nconst blankSources = [{ src: '' }];\n\nfunction getTrackSources(playlist, index) {\n  if (!isPlaylistValid(playlist)) {\n    return blankSources;\n  }\n  const { sources, url } = playlist[index];\n  if (sources) {\n    return sources.length ? sources : blankSources;\n  }\n  return [{ src: url }];\n}\n\nexport default getTrackSources;\n","import arrayFindIndex from 'array-find-index';\n\nfunction findTrackIndexByUrl(playlist, url) {\n  return arrayFindIndex(playlist, track => {\n    if (track.sources) {\n      return arrayFindIndex(track.sources, source => source.src === url) !== -1;\n    }\n    return track.url && url === track.url;\n  });\n}\n\nexport default findTrackIndexByUrl;\n","import getTrackSources from './getTrackSources';\n\n// collapses playlist into flat list containing\n// the first source url for each track\nfunction getSourceList(playlist) {\n  return (playlist || []).map((_, i) => getTrackSources(playlist, i)[0].src);\n}\n\nexport default getSourceList;\n","function getTimeRangesArray(timeRangesObj) {\n  const timeRangesArray = Array(timeRangesObj.length);\n  for (let i = 0; i < timeRangesObj.length; i++) {\n    timeRangesArray[i] = {\n      start: timeRangesObj.start(i),\n      end: timeRangesObj.end(i)\n    };\n  }\n  return timeRangesArray;\n}\n\nexport default getTimeRangesArray;\n","function getRepeatStrategy(loop, cycle) {\n  if (loop) {\n    return 'track';\n  }\n  if (cycle) {\n    return 'playlist';\n  }\n  return 'none';\n}\n\nexport default getRepeatStrategy;\n","function convertToNumberWithinIntervalBounds(number, min, max) {\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n  return Math.max(min, Math.min(number, max));\n}\n\nexport default convertToNumberWithinIntervalBounds;\n","function streamVideoElementToCanvas(videoElement, canvas, callback) {\n  const ctx = canvas.getContext('2d');\n  let requestId = null;\n  let widthSet = null;\n  let heightSet = null;\n  let placeholderImage = null;\n\n  requestId = requestAnimationFrame(streamToCanvas);\n\n  return {\n    endStream() {\n      cancelAnimationFrame(requestId);\n    },\n    setCanvasSize(width, height) {\n      widthSet = width || null;\n      heightSet = height || null;\n    },\n    setPlaceholderImage(img) {\n      placeholderImage = img || null;\n    }\n  };\n\n  function streamToCanvas() {\n    const { videoWidth, videoHeight } = videoElement;\n\n    // we want to draw the current frame image from the video element\n    let imageElement = videoElement;\n    let imageWidth = videoWidth;\n    let imageHeight = videoHeight;\n    let targetWidth = videoWidth;\n    let targetHeight = videoHeight;\n    let isVideo = true;\n\n    // however if there's no video to display (usually means we're playing\n    // media) then we want to display a placeholder image, if available\n    if (!(targetWidth && targetHeight) && placeholderImage) {\n      imageElement = placeholderImage;\n      imageWidth = placeholderImage.naturalWidth;\n      imageHeight = placeholderImage.naturalHeight;\n      targetWidth = placeholderImage.naturalWidth;\n      targetHeight = placeholderImage.naturalHeight;\n      isVideo = false;\n    }\n\n    // figure out what resolution the drawn image should be\n    if (widthSet && heightSet) {\n      targetWidth = widthSet;\n      targetHeight = heightSet;\n    } else if (widthSet) {\n      targetWidth = widthSet;\n      targetHeight = (widthSet / imageWidth) * imageHeight;\n    } else if (heightSet) {\n      targetHeight = heightSet;\n      targetWidth = (heightSet / imageHeight) * imageWidth;\n    }\n\n    // resize the canvas to the draw resolution if it doesn't already match\n    if (canvas.width !== targetWidth || canvas.height !== targetHeight) {\n      canvas.width = targetWidth;\n      canvas.height = targetHeight;\n    }\n\n    // draw\n    ctx.drawImage(imageElement, 0, 0, targetWidth, targetHeight);\n\n    // let the callback handle any post-processing\n    if (callback) {\n      callback(ctx, isVideo);\n    }\n\n    requestId = requestAnimationFrame(streamToCanvas);\n  }\n}\n\nexport default streamVideoElementToCanvas;\n","import React, { Component, Fragment, createElement } from 'react';\nimport PropTypes from 'prop-types';\nimport arrayFindIndex from 'array-find-index';\n\nimport PlayerContext from './PlayerContext';\nimport GroupContext from './GroupContext';\nimport * as PlayerPropTypes from './PlayerPropTypes';\nimport createCustomMediaElement from './factories/createCustomMediaElement';\nimport ShuffleManager from './utils/ShuffleManager';\nimport { getStateSnapshot, restoreStateFromSnapshot } from './utils/snapshot';\nimport getSourceList from './utils/getSourceList';\nimport getTrackSources from './utils/getTrackSources';\nimport getTimeRangesArray from './utils/getTimeRangesArray';\nimport findTrackIndexByUrl from './utils/findTrackIndexByUrl';\nimport isPlaylistValid from './utils/isPlaylistValid';\nimport getRepeatStrategy from './utils/getRepeatStrategy';\nimport convertToNumberWithinIntervalBounds from './utils/convertToNumberWithinIntervalBounds';\nimport streamVideoElementToCanvas from './utils/streamVideoElementToCanvas';\nimport { logError, logWarning } from './utils/console';\nimport { repeatStrategyOptions } from './constants';\n\nfunction playErrorHandler(err) {\n  logError(err);\n  if (err.name === 'NotAllowedError') {\n    const warningMessage =\n      'Media playback failed at ' +\n      new Date().toLocaleTimeString() +\n      '! (Perhaps autoplay is disabled in this browser.)';\n    logWarning(warningMessage);\n  }\n}\n\n// Existing Media Session API implementations have default handlers\n// for play/pause, and may yield unexpected behavior if custom\n// play/pause handlers are defined - so let's leave them be.\nconst supportableMediaSessionActions = [\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n];\n\n// media element readyState\nconst HAVE_NOTHING = 0;\n\nconst defaultState = {\n  // indicates whether media player should be paused\n  paused: true,\n  // elapsed time for active track, in seconds\n  currentTime: 0,\n  // The most recent targeted time, in seconds, for seek preview\n  seekPreviewTime: 0,\n  /* true if the user is currently dragging the mouse\n   * to seek a new track position\n   */\n  seekInProgress: false,\n  /* true if media was playing when seek previewing began,\n   * it was paused, and it should be resumed on seek\n   * complete\n   */\n  awaitingResumeOnSeekComplete: false,\n  // the duration in seconds of the loaded track\n  duration: 0,\n  // array describing the buffered ranges in the loaded track\n  bufferedRanges: [],\n  // array describing the already-played ranges in the loaded track\n  playedRanges: [],\n  // array describing the seekable ranges in the loaded track\n  seekableRanges: [],\n  // true if the media is currently stalled pending data buffering\n  stalled: false,\n  // true if the active track should play on the next componentDidUpdate\n  awaitingPlay: false\n};\n\n// assumes playlist is valid\nfunction getGoToTrackState(prevState, index, shouldPlay = true) {\n  const isNewTrack = prevState.activeTrackIndex !== index;\n  return {\n    activeTrackIndex: index,\n    trackLoading: isNewTrack,\n    currentTime: 0,\n    loop: isNewTrack ? false : prevState.loop,\n    awaitingPlay: Boolean(shouldPlay),\n    paused: !shouldPlay\n  };\n}\n\n/**\n * Wraps an area which shares a common [`playerContext`](#playercontext)\n */\nexport class PlayerContextProvider extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      ...defaultState,\n      // index matching requested track (whether track has loaded or not)\n      activeTrackIndex: convertToNumberWithinIntervalBounds(\n        props.startingTrackIndex,\n        0\n      ),\n      // whether we're waiting on loading metadata for the active track\n      trackLoading: isPlaylistValid(props.playlist),\n      // the current timestamp on the active track in seconds\n      currentTime: convertToNumberWithinIntervalBounds(props.startingTime, 0),\n      // the latest volume of the media, between 0 and 1.\n      volume: convertToNumberWithinIntervalBounds(props.defaultVolume, 0, 1),\n      // true if the media has been muted\n      muted: props.defaultMuted,\n      // whether to loop the active track\n      loop: props.defaultRepeatStrategy === 'track',\n      // true if playlist should continue at start after completion\n      cycle: props.defaultRepeatStrategy === 'playlist',\n      // whether to randomly pick next track from playlist after one finishes\n      shuffle: props.defaultShuffle,\n      // Rate at which media should be played. 1.0 is normal speed.\n      playbackRate: props.defaultPlaybackRate,\n      // true if user is currently dragging mouse to change the volume\n      setVolumeInProgress: false,\n      // initialize awaitingPlay from autoplay prop\n      awaitingPlay: props.autoplay && isPlaylistValid(props.playlist),\n      // playlist prop copied to state (for getDerivedStateFromProps)\n      __playlist__: props.playlist,\n      // load overrides from previously-captured state snapshot\n      ...(props.initialStateSnapshot\n        ? restoreStateFromSnapshot(props.initialStateSnapshot, props)\n        : {})\n    };\n\n    // volume at last time we were unmuted and not actively setting volume\n    this.lastStableVolume = this.state.volume;\n\n    // used to keep track of play history when we are shuffling\n    this.shuffler = new ShuffleManager(getSourceList(props.playlist), {\n      allowBackShuffle: props.allowBackShuffle\n    });\n\n    // html media element used for playback\n    this.media = null;\n\n    this.setMediaElementRef = this.setMediaElementRef.bind(this);\n\n    // bind callback methods to pass to descendant elements\n    this.togglePause = this.togglePause.bind(this);\n    this.selectTrackIndex = this.selectTrackIndex.bind(this);\n    this.forwardSkip = this.forwardSkip.bind(this);\n    this.backSkip = this.backSkip.bind(this);\n    this.seekPreview = this.seekPreview.bind(this);\n    this.seekComplete = this.seekComplete.bind(this);\n    this.setVolume = this.setVolume.bind(this);\n    this.setVolumeComplete = this.setVolumeComplete.bind(this);\n    this.toggleMuted = this.toggleMuted.bind(this);\n    this.toggleShuffle = this.toggleShuffle.bind(this);\n    this.setRepeatStrategy = this.setRepeatStrategy.bind(this);\n    this.setPlaybackRate = this.setPlaybackRate.bind(this);\n    this.pipeVideoStreamToCanvas = this.pipeVideoStreamToCanvas.bind(this);\n\n    // bind media event handlers\n    this.handleMediaPlay = this.handleMediaPlay.bind(this);\n    this.handleMediaPause = this.handleMediaPause.bind(this);\n    this.handleMediaSrcrequest = this.handleMediaSrcrequest.bind(this);\n    this.handleMediaEnded = this.handleMediaEnded.bind(this);\n    this.handleMediaStalled = this.handleMediaStalled.bind(this);\n    this.handleMediaCanplaythrough = this.handleMediaCanplaythrough.bind(this);\n    this.handleMediaTimeupdate = this.handleMediaTimeupdate.bind(this);\n    this.handleMediaLoadedmetadata = this.handleMediaLoadedmetadata.bind(this);\n    this.handleMediaVolumechange = this.handleMediaVolumechange.bind(this);\n    this.handleMediaDurationchange = this.handleMediaDurationchange.bind(this);\n    this.handleMediaProgress = this.handleMediaProgress.bind(this);\n    this.handleMediaLoopchange = this.handleMediaLoopchange.bind(this);\n    this.handleMediaRatechange = this.handleMediaRatechange.bind(this);\n  }\n\n  componentDidMount() {\n    const media = (this.media = createCustomMediaElement(this.media));\n\n    // initialize media properties\n    if (media.readyState !== HAVE_NOTHING) {\n      // we only set the currentTime now if we're beyond the\n      // HAVE_NOTHING readyState. Otherwise we'll let this get\n      // set when the loadedmetadata event fires. This avoids\n      // an issue where some browsers ignore or delay currentTime\n      // updates when in the HAVE_NOTHING state.\n      media.currentTime = this.state.currentTime;\n    }\n    media.volume = this.state.volume;\n    media.muted = this.state.muted;\n    media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n    media.playbackRate = this.state.playbackRate;\n\n    // add special event listeners on the media element\n    media.addEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.addEventListener('loopchange', this.handleMediaLoopchange);\n\n    if (this.state.awaitingPlay) {\n      this.setState({\n        awaitingPlay: false\n      });\n      this.delayTimeout = setTimeout(() => {\n        this.togglePause(false);\n      }, this.props.autoplayDelayInSeconds * 1000);\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const newPlaylist = nextProps.playlist;\n\n    if (newPlaylist === prevState.__playlist__) {\n      // reference comparison is equal so we'll\n      // assume the playlist is unchanged.\n      return null;\n    }\n\n    const baseNewState = {\n      __playlist__: newPlaylist\n    };\n\n    // check if the new playlist is invalid\n    if (!isPlaylistValid(newPlaylist)) {\n      return {\n        ...defaultState,\n        ...baseNewState,\n        activeTrackIndex: 0,\n        trackLoading: false\n      };\n    }\n\n    // check if the activeTrackIndex doesn't need to be updated\n    const prevSources = getTrackSources(\n      prevState.__playlist__,\n      prevState.activeTrackIndex\n    );\n    // the sources if we stay on the same track index\n    const currentSources = getTrackSources(\n      newPlaylist,\n      prevState.activeTrackIndex\n    );\n    // non-comprehensive but probably accurate check\n    if (prevSources[0].src === currentSources[0].src) {\n      // our active track index already matches\n      return baseNewState;\n    }\n\n    /* if the track we're already playing is in the new playlist, update the\n     * activeTrackIndex.\n     */\n    const newTrackIndex = findTrackIndexByUrl(newPlaylist, prevSources[0].src);\n    if (newTrackIndex !== -1) {\n      return {\n        ...baseNewState,\n        activeTrackIndex: newTrackIndex\n      };\n    }\n\n    // if not, then load the first track in the new playlist, and pause.\n    return {\n      ...baseNewState,\n      ...getGoToTrackState(prevState, 0, false)\n    };\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n\n    this.shuffler.setList(getSourceList(this.props.playlist));\n    this.shuffler.setOptions({\n      allowBackShuffle: this.props.allowBackShuffle\n    });\n\n    const prevSources = getTrackSources(\n      prevProps.playlist,\n      prevState.activeTrackIndex\n    );\n    const newSources = getTrackSources(\n      this.props.playlist,\n      this.state.activeTrackIndex\n    );\n    if (prevSources[0].src !== newSources[0].src) {\n      // cancel playback and re-scan current sources\n      this.media.load();\n\n      if (!this.state.shuffle) {\n        // after toggling off shuffle, we defer clearing the shuffle\n        // history until we actually change tracks - if the user quickly\n        // toggles  shuffle off then back on again, we don't want to have\n        // lost our history.\n        this.shuffler.clear();\n      }\n    }\n\n    if (prevProps !== this.props && !this.media.paused) {\n      // update running media session based on new props\n      this.stealMediaSession();\n    }\n\n    if (this.state.awaitingPlay) {\n      this.setState({\n        awaitingPlay: false\n      });\n      // media.currentSrc is updated asynchronously so we should\n      // play async to avoid weird intermediate state issues\n      setTimeout(() => {\n        this.togglePause(false);\n      });\n    }\n\n    clearTimeout(this.snapshotUpdateTimeout);\n    this.snapshotUpdateTimeout = setTimeout(() => {\n      if (this.props.onStateSnapshot) {\n        this.props.onStateSnapshot(getStateSnapshot(this.state));\n      }\n    }, 100);\n  }\n\n  componentWillUnmount() {\n    const { media } = this;\n    // remove special event listeners on the media element\n    media.removeEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.removeEventListener('loopchange', this.handleMediaLoopchange);\n\n    clearTimeout(this.gapLengthTimeout);\n    clearTimeout(this.delayTimeout);\n  }\n\n  setMediaElementRef(ref) {\n    this.media = ref;\n    if (typeof this.props.mediaElementRef === 'function') {\n      this.props.mediaElementRef(ref);\n    }\n  }\n\n  stealMediaSession() {\n    if (\n      // eslint-disable-next-line no-undef\n      !(window.MediaSession && navigator.mediaSession instanceof MediaSession)\n    ) {\n      return;\n    }\n    // eslint-disable-next-line no-undef\n    navigator.mediaSession.metadata = new MediaMetadata(\n      this.props.playlist[this.state.activeTrackIndex]\n    );\n    supportableMediaSessionActions\n      .map(action => {\n        if (this.props.supportedMediaSessionActions.indexOf(action) === -1) {\n          return null;\n        }\n        const seekLength = this.props.mediaSessionSeekLengthInSeconds;\n        switch (action) {\n          case 'play':\n            return this.togglePause.bind(this, false);\n          case 'pause':\n            return this.togglePause.bind(this, true);\n          case 'previoustrack':\n            return this.backSkip;\n          case 'nexttrack':\n            return this.forwardSkip;\n          case 'seekbackward':\n            return () => (this.media.currentTime -= seekLength);\n          case 'seekforward':\n            return () => (this.media.currentTime += seekLength);\n          default:\n            return undefined;\n        }\n      })\n      .forEach((handler, i) => {\n        navigator.mediaSession.setActionHandler(\n          supportableMediaSessionActions[i],\n          handler\n        );\n      });\n  }\n\n  pipeVideoStreamToCanvas(canvas, callback) {\n    return streamVideoElementToCanvas(this.media, canvas, callback);\n  }\n\n  handleMediaPlay() {\n    this.setState(state => (state.paused === false ? null : { paused: false }));\n    this.stealMediaSession();\n  }\n\n  handleMediaPause() {\n    this.setState(state => (state.paused === true ? null : { paused: true }));\n  }\n\n  handleMediaSrcrequest(e) {\n    const { playlist } = this.props;\n    const sources = getTrackSources(playlist, this.state.activeTrackIndex);\n    if (arrayFindIndex(sources, s => s.src === e.srcRequested) !== -1) {\n      // we're good! nothing to update.\n      return;\n    }\n    // looks like 'src' was set from outside our component.\n    // let's see if we can use it.\n    const newTrackIndex = findTrackIndexByUrl(playlist, e.srcRequested);\n    if (newTrackIndex === -1) {\n      logError(\n        `Source '${e.srcRequested}' does not exist in the loaded playlist. ` +\n          `Make sure you've updated the 'playlist' prop to ` +\n          `PlayerContextProvider before you select this track!`\n      );\n      return;\n    }\n    this.selectTrackIndex(newTrackIndex);\n  }\n\n  handleMediaEnded() {\n    if (this.state.seekInProgress) {\n      // nothing to do if we're in the middle of a seek\n      // (this can happen if we're in seekMode: immediate)\n      return;\n    }\n    clearTimeout(this.gapLengthTimeout);\n    const { playlist, loadFirstTrackOnPlaylistComplete } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    const { cycle, activeTrackIndex } = this.state;\n    if (!cycle && activeTrackIndex + 1 >= playlist.length) {\n      if (loadFirstTrackOnPlaylistComplete) {\n        this.goToTrack(0, false);\n      }\n      return;\n    }\n    this.gapLengthTimeout = setTimeout(\n      this.forwardSkip,\n      this.props.gapLengthInSeconds * 1000\n    );\n  }\n\n  handleMediaStalled() {\n    this.setState(state => (state.stalled === true ? null : { stalled: true }));\n  }\n\n  handleMediaCanplaythrough() {\n    this.setState(\n      state => (state.stalled === false ? null : { stalled: false })\n    );\n  }\n\n  handleMediaTimeupdate() {\n    const { currentTime, played } = this.media;\n    this.setState({\n      currentTime,\n      playedRanges: getTimeRangesArray(played)\n    });\n  }\n\n  handleMediaLoadedmetadata() {\n    if (this.media.currentTime !== this.state.currentTime) {\n      this.media.currentTime = this.state.currentTime;\n    }\n    this.setState(\n      state => (state.trackLoading === false ? null : { trackLoading: false })\n    );\n  }\n\n  handleMediaVolumechange() {\n    const { volume, muted } = this.media;\n    this.setState({ volume, muted });\n  }\n\n  handleMediaDurationchange() {\n    const { duration } = this.media;\n    this.setState({ duration });\n  }\n\n  handleMediaProgress() {\n    this.setState({\n      bufferedRanges: getTimeRangesArray(this.media.buffered),\n      seekableRanges: getTimeRangesArray(this.media.seekable)\n    });\n  }\n\n  handleMediaLoopchange() {\n    const { loop } = this.media;\n    this.setState(state => (state.loop === loop ? null : { loop }));\n  }\n\n  handleMediaRatechange() {\n    const { playbackRate } = this.media;\n    this.setState(\n      state => (state.playbackRate === playbackRate ? null : { playbackRate })\n    );\n  }\n\n  togglePause(value) {\n    clearTimeout(this.delayTimeout);\n    const pause = typeof value === 'boolean' ? value : !this.state.paused;\n    if (pause) {\n      this.media.pause();\n      return;\n    }\n    if (!this.media.currentSrc) {\n      return;\n    }\n    try {\n      const playPromise = this.media.play();\n      if (playPromise && typeof playPromise.catch === 'function') {\n        playPromise\n          .catch(err => {\n            // AbortError is pretty much always called because we're skipping\n            // tracks quickly or hitting pause before a track has a chance to\n            // play. It's pretty safe to just ignore these error messages.\n            if (err.name !== 'AbortError') {\n              return Promise.reject(err);\n            }\n          })\n          .catch(playErrorHandler);\n      }\n    } catch (err) {\n      playErrorHandler(err);\n    }\n  }\n\n  // assumes playlist is valid - don't call without checking\n  goToTrack(index, shouldPlay = true) {\n    clearTimeout(this.delayTimeout);\n    this.setState(state => getGoToTrackState(state, index, shouldPlay));\n  }\n\n  selectTrackIndex(index) {\n    const { playlist } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    if (index < 0 || index > playlist.length) {\n      logWarning(`Playlist index ${index} is out of bounds!`);\n      return;\n    }\n    if (this.state.shuffle) {\n      this.shuffler.pickNextItem(index, this.state.activeTrackIndex);\n    }\n    this.goToTrack(index);\n  }\n\n  backSkip() {\n    const { playlist, stayOnBackSkipThreshold } = this.props;\n    const { media } = this;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      media.currentTime >= stayOnBackSkipThreshold ||\n      (!cycle && activeTrackIndex < 1)\n    ) {\n      media.currentTime = 0;\n      return;\n    }\n    let index;\n    if (shuffle) {\n      const previousItem = this.shuffler.findPreviousItem(activeTrackIndex);\n      if (previousItem === undefined) {\n        // if we aren't allowing backShuffle then we'll hit a stopping point.\n        media.currentTime = 0;\n        return;\n      }\n      index = findTrackIndexByUrl(playlist, previousItem);\n    } else {\n      index = activeTrackIndex - 1;\n      if (index < 0) {\n        index = playlist.length - 1;\n      }\n    }\n    this.goToTrack(index);\n  }\n\n  forwardSkip() {\n    const { playlist } = this.props;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      (!cycle && activeTrackIndex + 1 >= playlist.length)\n    ) {\n      return;\n    }\n    let index;\n    if (shuffle) {\n      index = findTrackIndexByUrl(\n        playlist,\n        this.shuffler.findNextItem(activeTrackIndex)\n      );\n    } else {\n      index = activeTrackIndex + 1;\n      if (index >= playlist.length) {\n        index = 0;\n      }\n    }\n    this.goToTrack(index);\n  }\n\n  seekPreview(targetTime) {\n    if (!isPlaylistValid(this.props.playlist)) {\n      return;\n    }\n    const baseStateUpdate = {\n      seekPreviewTime: targetTime,\n      seekInProgress: true\n    };\n    switch (this.props.seekMode) {\n      case 'paused':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true\n        }));\n        this.media.currentTime = targetTime;\n        if (!this.state.paused) {\n          this.togglePause(true);\n        }\n        break;\n      case 'immediate':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true\n        }));\n        this.media.currentTime = targetTime;\n        if (this.state.awaitingResumeOnSeekComplete && !this.media.ended) {\n          // if we earlier encountered an 'ended' state,\n          // un-pausing becomes necessary to resume playback\n          this.togglePause(false);\n        }\n        break;\n      case 'onrelease':\n        this.setState(baseStateUpdate);\n        break;\n    }\n  }\n\n  seekComplete() {\n    const { seekPreviewTime, awaitingResumeOnSeekComplete } = this.state;\n    const baseStateUpdate = {\n      seekInProgress: false,\n      awaitingResumeOnSeekComplete: false\n    };\n    if (isNaN(seekPreviewTime)) {\n      this.setState(baseStateUpdate);\n      return;\n    }\n    this.setState({\n      ...baseStateUpdate,\n      /* we'll update currentTime on the media listener hook anyway,\n       * but that might not happen for a bit... so the optimistic update\n       * helps us avoid the progress bar jumping around and confusing the user.\n       * https://github.com/benwiley4000/cassette/issues/209\n       */\n      currentTime: seekPreviewTime\n    });\n    this.media.currentTime = seekPreviewTime;\n    if (awaitingResumeOnSeekComplete) {\n      if (this.media.ended) {\n        this.forwardSkip();\n      } else {\n        this.togglePause(false);\n      }\n    }\n  }\n\n  setVolume(volume) {\n    if (!this.state.setVolumeInProgress) {\n      this.setState({\n        setVolumeInProgress: true\n      });\n    }\n    const volumeInBounds = convertToNumberWithinIntervalBounds(volume, 0, 1);\n    this.media.muted = volumeInBounds === 0 ? true : false;\n    this.media.volume = volumeInBounds;\n  }\n\n  setVolumeComplete() {\n    this.setState({\n      setVolumeInProgress: false\n    });\n    if (!this.media.muted) {\n      this.lastStableVolume = this.media.volume;\n    }\n  }\n\n  toggleMuted(value) {\n    const muted = typeof value === 'boolean' ? value : !this.state.muted;\n    this.media.muted = muted;\n    if (!muted) {\n      this.media.volume = this.lastStableVolume;\n    }\n  }\n\n  toggleShuffle(value) {\n    const shuffle = typeof value === 'boolean' ? value : !this.state.shuffle;\n    this.setState({ shuffle });\n  }\n\n  setRepeatStrategy(repeatStrategy) {\n    if (repeatStrategyOptions.indexOf(repeatStrategy) === -1) {\n      logWarning(\n        'repeatStrategy \"' +\n          repeatStrategy +\n          '\" is not one of: ' +\n          repeatStrategyOptions.split(', ') +\n          '.'\n      );\n      return;\n    }\n    this.setState(() => {\n      switch (repeatStrategy) {\n        case 'track':\n          return {\n            loop: true\n          };\n        case 'playlist':\n          return {\n            loop: false,\n            cycle: true\n          };\n        case 'none':\n          return {\n            loop: false,\n            cycle: false\n          };\n        default:\n          return null;\n      }\n    });\n  }\n\n  setPlaybackRate(rate) {\n    this.media.playbackRate = rate;\n  }\n\n  getControlProps() {\n    const { props, state } = this;\n    const playerContext = {\n      playlist: props.playlist,\n      activeTrackIndex: state.activeTrackIndex,\n      trackLoading: state.trackLoading,\n      paused: state.paused,\n      currentTime: state.currentTime,\n      seekPreviewTime: state.seekPreviewTime,\n      seekInProgress: state.seekInProgress,\n      awaitingResumeOnSeekComplete: state.awaitingResumeOnSeekComplete,\n      duration: state.duration,\n      bufferedRanges: state.bufferedRanges,\n      playedRanges: state.playedRanges,\n      seekableRanges: state.seekableRanges,\n      volume: state.volume,\n      muted: state.muted,\n      shuffle: state.shuffle,\n      stalled: state.stalled,\n      playbackRate: state.playbackRate,\n      setVolumeInProgress: state.setVolumeInProgress,\n      repeatStrategy: getRepeatStrategy(state.loop, state.cycle),\n      pipeVideoStreamToCanvas: this.pipeVideoStreamToCanvas,\n      onTogglePause: this.togglePause,\n      onSelectTrackIndex: this.selectTrackIndex,\n      onBackSkip: this.backSkip,\n      onForwardSkip: this.forwardSkip,\n      onSeekPreview: this.seekPreview,\n      onSeekComplete: this.seekComplete,\n      onSetVolume: this.setVolume,\n      onSetVolumeComplete: this.setVolumeComplete,\n      onToggleMuted: this.toggleMuted,\n      onToggleShuffle: this.toggleShuffle,\n      onSetRepeatStrategy: this.setRepeatStrategy,\n      onSetPlaybackRate: this.setPlaybackRate\n    };\n    if (this.playerContext) {\n      // only update this.playerContext if something has changed\n      for (const key of Object.keys(this.playerContext)) {\n        if (playerContext[key] !== this.playerContext[key]) {\n          this.playerContext = playerContext;\n          break;\n        }\n      }\n    } else {\n      // first time - nothing to compare\n      this.playerContext = playerContext;\n    }\n    return this.playerContext;\n  }\n\n  render() {\n    const sources = getTrackSources(\n      this.props.playlist,\n      this.state.activeTrackIndex\n    );\n    const playerContext = this.getControlProps();\n    return (\n      <Fragment>\n        <video\n          hidden\n          ref={this.setMediaElementRef}\n          crossOrigin={this.props.crossOrigin}\n          preload=\"metadata\"\n          loop={this.state.loop}\n          onPlay={this.handleMediaPlay}\n          onPause={this.handleMediaPause}\n          onEnded={this.handleMediaEnded}\n          onStalled={this.handleMediaStalled}\n          onCanPlayThrough={this.handleMediaCanplaythrough}\n          onTimeUpdate={this.handleMediaTimeupdate}\n          onLoadedMetadata={this.handleMediaLoadedmetadata}\n          onVolumeChange={this.handleMediaVolumechange}\n          onDurationChange={this.handleMediaDurationchange}\n          onProgress={this.handleMediaProgress}\n          onRateChange={this.handleMediaRatechange}\n        >\n          {sources.map(source => (\n            <source key={source.src} src={source.src} type={source.type} />\n          ))}\n        </video>\n        <PlayerContext.Provider value={playerContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(playerContext)\n            : this.props.children}\n        </PlayerContext.Provider>\n      </Fragment>\n    );\n  }\n}\n\nPlayerContextProvider.propTypes = {\n  playlist: PropTypes.arrayOf(PlayerPropTypes.track.isRequired).isRequired,\n  autoplay: PropTypes.bool.isRequired,\n  autoplayDelayInSeconds: PropTypes.number.isRequired,\n  gapLengthInSeconds: PropTypes.number.isRequired,\n  crossOrigin: PlayerPropTypes.crossOriginAttribute,\n  defaultVolume: PropTypes.number.isRequired,\n  defaultMuted: PropTypes.bool,\n  defaultRepeatStrategy: PlayerPropTypes.repeatStrategy.isRequired,\n  defaultShuffle: PropTypes.bool,\n  defaultPlaybackRate: PropTypes.number.isRequired,\n  startingTime: PropTypes.number.isRequired,\n  startingTrackIndex: PropTypes.number.isRequired,\n  loadFirstTrackOnPlaylistComplete: PropTypes.bool,\n  seekMode: PlayerPropTypes.seekMode.isRequired,\n  maintainPlaybackRate: PropTypes.bool.isRequired,\n  allowBackShuffle: PropTypes.bool,\n  stayOnBackSkipThreshold: PropTypes.number.isRequired,\n  supportedMediaSessionActions: PropTypes.arrayOf(\n    PlayerPropTypes.mediaSessionAction.isRequired\n  ).isRequired,\n  mediaSessionSeekLengthInSeconds: PropTypes.number.isRequired,\n  mediaElementRef: PropTypes.func,\n  initialStateSnapshot: PropTypes.shape({\n    __unstable__: PropTypes.object.isRequired\n  }),\n  onStateSnapshot: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nPlayerContextProvider.defaultProps = {\n  autoplay: false,\n  autoplayDelayInSeconds: 0,\n  gapLengthInSeconds: 0,\n  defaultVolume: 1,\n  defaultMuted: false,\n  defaultRepeatStrategy: 'playlist',\n  defaultShuffle: false,\n  defaultPlaybackRate: 1,\n  startingTime: 0,\n  startingTrackIndex: 0,\n  loadFirstTrackOnPlaylistComplete: true,\n  seekMode: 'immediate',\n  maintainPlaybackRate: false,\n  allowBackShuffle: false,\n  stayOnBackSkipThreshold: 5,\n  supportedMediaSessionActions: ['play', 'pause', 'previoustrack', 'nexttrack'],\n  mediaSessionSeekLengthInSeconds: 10\n};\n\nexport class PlayerContextGroupMember extends Component {\n  componentDidMount() {\n    this.props.groupContext.registerMediaElement(this.mediaElement);\n  }\n\n  componentWillUnmount() {\n    this.props.groupContext.unregisterMediaElement(this.mediaElement);\n  }\n\n  render() {\n    const { groupContext, props } = this.props;\n    const { mediaElementRef, ...rest } = props;\n    return (\n      <PlayerContextProvider\n        {...groupContext.groupProps}\n        {...rest}\n        mediaElementRef={ref => {\n          if (mediaElementRef) {\n            mediaElementRef(ref);\n          }\n          this.mediaElement = ref;\n        }}\n      />\n    );\n  }\n}\n\nPlayerContextGroupMember.propTypes = {\n  groupContext: PropTypes.shape({\n    groupProps: PropTypes.object.isRequired,\n    registerMediaElement: PropTypes.func.isRequired,\n    unregisterMediaElement: PropTypes.func.isRequired\n  }).isRequired\n};\n\nfunction PlayerContextGroupConsumer(props) {\n  return (\n    <GroupContext.Consumer>\n      {groupContext => {\n        if (!groupContext) {\n          return createElement(PlayerContextProvider, props);\n        }\n        return createElement(PlayerContextGroupMember, {\n          groupContext,\n          props\n        });\n      }}\n    </GroupContext.Consumer>\n  );\n}\n\nexport default PlayerContextGroupConsumer;\n","import isPlaylistValid from './isPlaylistValid';\nimport getTrackSources from './getTrackSources';\nimport findTrackIndexByUrl from './findTrackIndexByUrl';\n\nexport function getStateSnapshot(state) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    __playlist__\n  } = state;\n  return {\n    __unstable__: {\n      paused,\n      currentTime,\n      activeTrackIndex,\n      volume,\n      muted,\n      loop,\n      cycle,\n      shuffle,\n      playbackRate,\n      activeTrackSrc: isPlaylistValid(__playlist__)\n        ? getTrackSources(__playlist__, activeTrackIndex)[0].src\n        : null\n    }\n  };\n}\n\nexport function restoreStateFromSnapshot(snapshot, props) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    activeTrackSrc\n  } = snapshot.__unstable__;\n  const restoredStateValues = {};\n  if (isPlaylistValid(props.playlist) && typeof paused === 'boolean') {\n    // using awaitingPlay instead of paused triggers an animation\n    restoredStateValues.awaitingPlay = !paused;\n  }\n  if (typeof volume === 'number' && volume >= 0 && volume <= 1) {\n    restoredStateValues.volume = volume;\n  }\n  if (typeof muted === 'boolean') {\n    restoredStateValues.muted = muted;\n  }\n  if (typeof loop === 'boolean') {\n    restoredStateValues.loop = loop;\n  }\n  if (typeof cycle === 'boolean') {\n    restoredStateValues.cycle = cycle;\n  }\n  if (typeof shuffle === 'boolean') {\n    restoredStateValues.shuffle = shuffle;\n  }\n  if (typeof playbackRate === 'number') {\n    restoredStateValues.playbackRate = playbackRate;\n  }\n  let useCurrentTime = false;\n  if (\n    typeof activeTrackSrc === 'string' &&\n    typeof activeTrackIndex === 'number' &&\n    activeTrackIndex >= 0\n  ) {\n    // let's try staying on the same track index\n    const currentSrc = getTrackSources(props.playlist, activeTrackIndex)[0].src;\n    if (activeTrackSrc === currentSrc) {\n      restoredStateValues.activeTrackIndex = activeTrackIndex;\n      useCurrentTime = true;\n    } else {\n      /* if the track we were playing before is in the new playlist,\n       * update the activeTrackIndex.\n       */\n      const newTrackIndex = findTrackIndexByUrl(props.playlist, activeTrackSrc);\n      if (newTrackIndex !== -1) {\n        restoredStateValues.activeTrackIndex = newTrackIndex;\n        useCurrentTime = true;\n      }\n    }\n  }\n  if (useCurrentTime && typeof currentTime === 'number' && currentTime >= 0) {\n    restoredStateValues.currentTime = currentTime;\n  }\n  return restoredStateValues;\n}\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport GroupContext from './GroupContext';\n\n/**\n * A wrapper which can be used to share configuration among multiple descendant [`PlayerContextProvider`](#playercontextprovider) instances as well as prevent multiple media elements from playing audio simultaneously\n */\nexport class PlayerContextGroup extends Component {\n  constructor(props) {\n    super(props);\n    this.registerMediaElement = this.registerMediaElement.bind(this);\n    this.unregisterMediaElement = this.unregisterMediaElement.bind(this);\n    this.enforceOneMediaSourceOnly = this.enforceOneMediaSourceOnly.bind(this);\n    this.mediaElements = [];\n  }\n\n  registerMediaElement(elem) {\n    this.mediaElements = this.mediaElements.concat(elem);\n    elem.addEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.addEventListener('volumechange', this.enforceOneMediaSourceOnly, true);\n  }\n\n  unregisterMediaElement(elem) {\n    this.mediaElements = this.mediaElements.filter(element => elem !== element);\n    elem.removeEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.removeEventListener(\n      'volumechange',\n      this.enforceOneMediaSourceOnly,\n      true\n    );\n  }\n\n  enforceOneMediaSourceOnly(e) {\n    const mediaElement = e.target;\n    const { paused, muted } = mediaElement;\n    if (paused || muted) {\n      return;\n    }\n    for (const element of this.mediaElements) {\n      if (element !== mediaElement && !element.muted) {\n        element.pause();\n      }\n    }\n  }\n\n  render() {\n    return (\n      <GroupContext.Consumer>\n        {groupContext => {\n          const value = groupContext\n            ? {\n                ...groupContext,\n                groupProps: { ...groupContext.groupProps, ...this.props }\n              }\n            : {\n                groupProps: this.props,\n                registerMediaElement: this.registerMediaElement,\n                unregisterMediaElement: this.unregisterMediaElement\n              };\n          return (\n            <GroupContext.Provider value={value}>\n              {this.props.children}\n            </GroupContext.Provider>\n          );\n        }}\n      </GroupContext.Consumer>\n    );\n  }\n}\n\nPlayerContextGroup.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\nexport default PlayerContextGroup;\n","import { createContext } from 'react';\n\nimport { logWarning } from './utils/console';\n\nconst FullscreenContext = createContext({\n  fullscreen: false,\n  requestFullscreen() {\n    logWarning(\n      'Fullscreen request ignored since there is no ' +\n        'FullscreenContextProvider ancestor.'\n    );\n  },\n  requestExitFullscreen() {\n    logWarning(\n      'Exit fullscreen request ignored since there is no ' +\n        'FullscreenContextProvider ancestor.'\n    );\n  }\n});\nFullscreenContext.displayName = 'FullscreenContext';\n\nexport default FullscreenContext;\n","import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nimport FullscreenContext from './FullscreenContext';\n\nconst fullscreenStyle = {\n  width: '100%',\n  height: '100%'\n};\n\n/**\n * Wraps an area which should be fullscreen-able\n */\nexport class FullscreenContextProvider extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      fullscreen: false\n    };\n    this.requestFullscreen = this.requestFullscreen.bind(this);\n    this.requestExitFullscreen = this.requestExitFullscreen.bind(this);\n    this.handleFullscreenChange = this.handleFullscreenChange.bind(this);\n    this.fullscreenElement = null;\n  }\n\n  componentDidMount() {\n    document.addEventListener('fullscreenchange', this.handleFullscreenChange);\n    document.addEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\n      'fullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  requestFullscreen() {\n    if (!this.props.fullscreenEnabled) {\n      return;\n    }\n    if (this.fullscreenElement.requestFullscreen) {\n      this.fullscreenElement.requestFullscreen();\n    } else if (this.fullscreenElement.webkitRequestFullscreen) {\n      this.fullscreenElement.webkitRequestFullscreen();\n    } else if (this.fullscreenElement.mozRequestFullscreen) {\n      this.fullscreenElement.mozRequestFullScreen();\n    } else if (this.fullscreenElement.msRequestFullscreen) {\n      this.fullscreenElement.msRequestFullscreen();\n    }\n  }\n\n  requestExitFullscreen() {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    } else if (document.webkitCancelFullScreen) {\n      document.webkitCancelFullScreen();\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen();\n    } else if (document.msExitFullscreen) {\n      document.mozExitFullscreen();\n    }\n  }\n\n  handleFullscreenChange() {\n    const documentFullscreenElement =\n      document.fullscreenElement ||\n      document.webkitFullscreenElement ||\n      document.mozFullScreenElement ||\n      document.msFullscreenElement;\n    this.setState({\n      fullscreen: documentFullscreenElement === this.fullscreenElement\n    });\n  }\n\n  getFullscreenContext() {\n    const fullscreenContext = {\n      fullscreen: this.state.fullscreen,\n      requestFullscreen: this.requestFullscreen,\n      requestExitFullscreen: this.requestExitFullscreen\n    };\n    if (\n      this.fullscreenContext &&\n      fullscreenContext.fullscreen === this.fullscreenContext.fullscreen\n    ) {\n      // no change\n      return this.fullscreenContext;\n    }\n    return (this.fullscreenContext = fullscreenContext);\n  }\n\n  render() {\n    const fullscreenContext = this.getFullscreenContext();\n    return (\n      <div\n        ref={elem => (this.fullscreenElement = elem)}\n        style={this.state.fullscreen ? fullscreenStyle : undefined}\n      >\n        <FullscreenContext.Provider value={fullscreenContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(fullscreenContext)\n            : this.props.children}\n        </FullscreenContext.Provider>\n      </div>\n    );\n  }\n}\n\nFullscreenContextProvider.propTypes = {\n  fullscreenEnabled: PropTypes.bool.isRequired,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nFullscreenContextProvider.defaultProps = {\n  fullscreenEnabled: true\n};\n\nexport default FullscreenContextProvider;\n","import React, { createElement } from 'react';\n\nimport PlayerContext from './PlayerContext';\nimport FullscreenContext from './FullscreenContext';\nimport { logWarning } from './utils/console';\n\nfunction playerContextFilter(component, contextPropNames) {\n  const warned = {};\n  const childName = component.displayName || component.name;\n  function PlayerContextFilter(props) {\n    return (\n      <FullscreenContext.Consumer>\n        {fullscreenContext => (\n          <PlayerContext.Consumer>\n            {playerContext => {\n              const childProps = { ...props };\n              for (const propName of contextPropNames) {\n                if (playerContext.hasOwnProperty(propName)) {\n                  childProps[propName] = playerContext[propName];\n                } else if (fullscreenContext.hasOwnProperty(propName)) {\n                  childProps[propName] = fullscreenContext[propName];\n                } else if (!warned[propName]) {\n                  logWarning(\n                    \"Prop '\" +\n                      propName +\n                      \"' for component \" +\n                      childName +\n                      ' not found in playerContext or fullscreenContext.'\n                  );\n                  warned[propName] = true;\n                }\n              }\n              return createElement(component, childProps);\n            }}\n          </PlayerContext.Consumer>\n        )}\n      </FullscreenContext.Consumer>\n    );\n  }\n  if (childName) {\n    PlayerContextFilter.displayName = `PlayerContextFilter(${childName})`;\n  }\n  return PlayerContextFilter;\n}\n\nexport default playerContextFilter;\n","import PlayerContextProvider from './PlayerContextProvider';\nimport PlayerContext from './PlayerContext';\nimport PlayerContextGroup from './PlayerContextGroup';\nimport FullscreenContextProvider from './FullscreenContextProvider';\nimport FullscreenContext from './FullscreenContext';\nimport playerContextFilter from './playerContextFilter';\nimport * as PlayerPropTypes from './PlayerPropTypes';\n\nexport { PlayerContextProvider };\nexport const PlayerContextConsumer = PlayerContext.Consumer;\nexport { PlayerContextGroup };\nexport { FullscreenContextProvider };\nexport const FullscreenContextConsumer = FullscreenContext.Consumer;\nexport { playerContextFilter };\nexport { PlayerPropTypes };\n\n// undocumented exports\nexport * from './utils/console';\nexport {\n  default as convertToNumberWithinIntervalBounds\n} from './utils/convertToNumberWithinIntervalBounds';\nexport { default as isPlaylistValid } from './utils/isPlaylistValid';\nexport { repeatStrategyOptions } from './constants';\n"],"sourceRoot":""}