{"version":3,"sources":["webpack://cassetteCore/webpack/universalModuleDefinition","webpack://cassetteCore/webpack/bootstrap","webpack://cassetteCore/external {\"root\":\"React\",\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\"}","webpack://cassetteCore/external {\"root\":\"PropTypes\",\"commonjs\":\"prop-types\",\"commonjs2\":\"prop-types\",\"amd\":\"prop-types\"}","webpack://cassetteCore/./packages/core/src/utils/console.js","webpack://cassetteCore/./packages/core/src/utils/createSingleGlobalContext.js","webpack://cassetteCore/./packages/core/node_modules/array-find-index/index.js","webpack://cassetteCore/(webpack)/buildin/global.js","webpack://cassetteCore/./packages/core/src/PlayerContext.js","webpack://cassetteCore/./packages/core/src/GroupContext.js","webpack://cassetteCore/./packages/core/src/constants.js","webpack://cassetteCore/./packages/core/src/PlayerPropTypes.js","webpack://cassetteCore/./packages/core/src/factories/createCustomMediaElement.js","webpack://cassetteCore/./packages/core/src/utils/ShuffleManager.js","webpack://cassetteCore/./packages/core/src/utils/isPlaylistValid.js","webpack://cassetteCore/./packages/core/src/utils/getTrackSources.js","webpack://cassetteCore/./packages/core/src/utils/findTrackIndexByUrl.js","webpack://cassetteCore/./packages/core/src/utils/getSourceList.js","webpack://cassetteCore/./packages/core/src/utils/getTimeRangesArray.js","webpack://cassetteCore/./packages/core/src/utils/getRepeatStrategy.js","webpack://cassetteCore/./packages/core/src/utils/convertToNumberWithinIntervalBounds.js","webpack://cassetteCore/./packages/core/src/PlayerContextProvider.js","webpack://cassetteCore/./packages/core/src/utils/snapshot.js","webpack://cassetteCore/./packages/core/src/PlayerContextGroup.js","webpack://cassetteCore/./packages/core/src/FullscreenContext.js","webpack://cassetteCore/./packages/core/src/FullscreenContextProvider.js","webpack://cassetteCore/./packages/core/src/playerContextFilter.js","webpack://cassetteCore/./packages/core/src/index.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","logWarning","log","console","logError","error","warn","packageVersion","version","_global","window","global","__cassette_contexts__","displayName","defaultValue","ExistingContext","_console__WEBPACK_IMPORTED_MODULE_1__","Context","react__WEBPACK_IMPORTED_MODULE_0__","arr","predicate","ctx","Array","findIndex","TypeError","list","len","length","g","Function","eval","e","PlayerContext","createSingleGlobalContext","GroupContext","repeatStrategyOptions","requiredOnlyUnlessHasProp","propType","altPropName","warnedAboutDefiningBoth","props","propName","componentName","_len","arguments","rest","_key","isRequired","apply","concat","Error","controlKeyword","external_root_PropTypes_commonjs_prop_types_commonjs2_prop_types_amd_prop_types_default","a","oneOf","control","oneOfType","func","crossOriginAttribute","PlayerPropTypes_repeatStrategy","mediaSource","shape","src","string","type","mediaSessionAction","mediaSessionArtwork","sizes","PlayerPropTypes_track","url","sources","arrayOf","title","artist","album","artwork","meta","progressDirection","seekMode","aspectRatio","prop","undefined","split","some","isNaN","loopchange","srcrequest","factories_createCustomMediaElement","media","document","createElement","MutationObserver","dispatchEvent","Event","observe","attributes","attributeFilter","currentSrc","set","srcRequested","_goForward","forwardStack","backStack","currentItem","item","push","pop","_findNextItem","allowMore","indexOf","_allItemsMatch","nextItem","Math","floor","random","utils_ShuffleManager","ShuffleManager","options","_list","_forwardStack","_backStack","_currentItem","_allowBackShuffle","Boolean","allowBackShuffle","_proto","findNextItem","currentIndex","setCurrentIndex","findPreviousItem","pickNextItem","index","setList","setOptions","_arr","keys","_i","clear","utils_isPlaylistValid","playlist","blankSources","utils_getTrackSources","_playlist$index","utils_findTrackIndexByUrl","array_find_index_default","track","source","utils_getSourceList","map","_","utils_getTimeRangesArray","timeRangesObj","timeRangesArray","start","end","utils_getRepeatStrategy","loop","cycle","utils_convertToNumberWithinIntervalBounds","number","min","max","Infinity","playErrorHandler","err","warningMessage","Date","toLocaleTimeString","supportableMediaSessionActions","defaultState","paused","currentTime","seekPreviewTime","seekInProgress","awaitingResumeOnSeekComplete","duration","bufferedRanges","playedRanges","seekableRanges","stalled","awaitingPlay","getGoToTrackState","_ref","prevState","_ref$shouldPlay","shouldPlay","_ref$shouldForceLoad","shouldForceLoad","isNewTrack","activeTrackIndex","trackLoading","awaitingForceLoad","setMediaElementSources","mediaElement","firstChild","removeChild","_iterator","_isArray","isArray","iterator","_ref2","next","done","sourceElement","appendChild","load","PlayerContextProvider_PlayerContextProvider","_Component","PlayerContextProvider","_this","state","_objectSpread","startingTrackIndex","startingTime","volume","defaultVolume","muted","defaultMuted","defaultRepeatStrategy","shuffle","defaultShuffle","playbackRate","defaultPlaybackRate","setVolumeInProgress","autoplay","__playlist__","initialStateSnapshot","snapshot","_snapshot$__unstable_","__unstable__","activeTrackSrc","restoredStateValues","useCurrentTime","newTrackIndex","restoreStateFromSnapshot","lastStableVolume","shuffler","videoHostElementList","videoHostOccupiedCallbacks","Map","videoHostVacatedCallbacks","togglePause","_assertThisInitialized","selectTrackIndex","forwardSkip","backSkip","seekPreview","seekComplete","setVolume","setVolumeComplete","toggleMuted","toggleShuffle","setRepeatStrategy","setPlaybackRate","registerVideoHostElement","renderVideoIntoHostElement","unregisterVideoHostElement","updateVideoHostElement","handleMediaPlay","handleMediaPause","handleMediaSrcrequest","handleMediaEnded","handleMediaStalled","handleMediaCanplaythrough","handleMediaTimeupdate","handleMediaLoadedmetadata","handleMediaVolumechange","handleMediaDurationchange","handleMediaProgress","handleMediaLoopchange","handleMediaRatechange","_inheritsLoose","componentDidMount","_this2","_this$props","crossOrigin","autoplayDelayInSeconds","mediaElementRef","getPosterImageForTrack","onActiveTrackUpdate","_this$state","setAttribute","addEventListener","mediaContainer","setState","delayTimeout","setTimeout","getDerivedStateFromProps","nextProps","newPlaylist","baseNewState","prevSources","currentSources","componentDidUpdate","prevProps","_this3","newSources","prevTrack","newTrack","stealMediaSession","clearTimeout","snapshotUpdateTimeout","onStateSnapshot","getStateSnapshot","componentWillUnmount","removeEventListener","gapLengthTimeout","_this4","MediaSession","navigator","mediaSession","metadata","MediaMetadata","action","supportedMediaSessionActions","seekLength","mediaSessionSeekLengthInSeconds","forEach","handler","setActionHandler","hostElement","_ref3","onHostOccupied","onHostVacated","_this5","cancelAnimationFrame","videoHostUpdateRaf","requestAnimationFrame","filter","elem","delete","parentNode","playing","oldHostElement","play","onVacated","onOccupied","_this$props2","loadFirstTrackOnPlaylistComplete","_this$state2","goToTrack","gapLengthInSeconds","_this$media","played","_this$media2","buffered","seekable","pause","playPromise","catch","Promise","reject","args","_this$props3","stayOnBackSkipThreshold","_this$state3","previousItem","_this$state4","targetTime","baseStateUpdate","_ref4","_ref5","ended","_this$state5","inProgress","volumeInBounds","repeatStrategy","rate","getControlProps","playerContext","onTogglePause","onSelectTrackIndex","onBackSkip","onForwardSkip","onSeekPreview","onSeekComplete","onSetVolume","onSetVolumeComplete","onToggleMuted","onToggleShuffle","onSetRepeatStrategy","onSetPlaybackRate","_i2","render","_this6","external_root_React_commonjs_react_commonjs2_react_amd_react_default","external_root_React_commonjs_react_commonjs2_react_amd_react_","ref","hidden","Provider","children","defaultProps","maintainPlaybackRate","PlayerContextProvider_PlayerContextGroupMember","_Component2","PlayerContextGroupMember","_proto2","groupContext","registerMediaElement","unregisterMediaElement","_this7","_this$props4","_objectWithoutPropertiesLoose","_extends","groupProps","src_PlayerContextProvider","Consumer","src_PlayerContextGroup","PlayerContextGroup","PlayerContextGroup_assertThisInitialized","enforceOneMediaSourceOnly","mediaElements","PlayerContextGroup_inheritsLoose","element","target","PlayerContextGroup_objectSpread","FullscreenContext","fullscreen","requestFullscreen","requestExitFullscreen","fullscreenStyle","width","height","FullscreenContextProvider_FullscreenContextProvider","_PureComponent","FullscreenContextProvider","FullscreenContextProvider_assertThisInitialized","handleFullscreenChange","fullscreenElement","FullscreenContextProvider_inheritsLoose","fullscreenEnabled","webkitRequestFullscreen","mozRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","webkitCancelFullScreen","mozCancelFullScreen","msExitFullscreen","mozExitFullscreen","documentFullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","getFullscreenContext","fullscreenContext","style","src_FullscreenContextProvider","src_playerContextFilter","component","contextPropNames","warned","childName","PlayerContextFilter","childProps","playerContextFilter_objectSpread","PlayerContextConsumer","FullscreenContextConsumer"],"mappings":"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","file":"es5/cassette-core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"prop-types\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"prop-types\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cassetteCore\"] = factory(require(\"react\"), require(\"prop-types\"));\n\telse\n\t\troot[\"cassetteCore\"] = factory(root[\"React\"], root[\"PropTypes\"]);\n})((typeof self !== \"undefined\" ? self : this), function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","/* eslint-disable no-console */\n\nconst log = console.log.bind(console);\n\nexport const logError = console.error ? console.error.bind(console) : log;\nexport const logWarning = console.warn ? console.warn.bind(console) : log;\n","import { createContext } from 'react';\n\nimport { logWarning } from './console';\n\nconst packageVersion = require('../../package.json').version;\n\nconst _global = typeof window === 'undefined' ? global : window;\n_global.__cassette_contexts__ = _global.__cassette_contexts__ || {};\n\nfunction createSingleGlobalContext(displayName, defaultValue = null) {\n  const ExistingContext = _global.__cassette_contexts__[displayName];\n  if (ExistingContext) {\n    if (ExistingContext.packageVersion !== packageVersion) {\n      logWarning(\n        `Warning: multiple versions of ${displayName} from the @cassette/core` +\n          ` package have been loaded. v${packageVersion} will be ignored and` +\n          ` v${ExistingContext.packageVersion} will be used instead.`\n      );\n    }\n    return ExistingContext;\n  }\n  const Context = createContext(defaultValue);\n  Context.displayName = displayName;\n  Context.packageVersion = packageVersion;\n  _global.__cassette_contexts__[displayName] = Context;\n  return Context;\n}\n\nexport default createSingleGlobalContext;\n","'use strict';\nmodule.exports = function (arr, predicate, ctx) {\n\tif (typeof Array.prototype.findIndex === 'function') {\n\t\treturn arr.findIndex(predicate, ctx);\n\t}\n\n\tif (typeof predicate !== 'function') {\n\t\tthrow new TypeError('predicate must be a function');\n\t}\n\n\tvar list = Object(arr);\n\tvar len = list.length;\n\n\tif (len === 0) {\n\t\treturn -1;\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tif (predicate.call(ctx, list[i], i, list)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import createSingleGlobalContext from './utils/createSingleGlobalContext';\n\nexport default createSingleGlobalContext('PlayerContext');\n","import createSingleGlobalContext from './utils/createSingleGlobalContext';\n\nexport default createSingleGlobalContext('GroupContext');\n","export const repeatStrategyOptions = ['none', 'playlist', 'track'];\n","import PropTypes from 'prop-types';\n\nimport { repeatStrategyOptions } from './constants';\nimport { logWarning } from './utils/console';\n\nfunction requiredOnlyUnlessHasProp(propType, altPropName) {\n  let warnedAboutDefiningBoth = false;\n  function validate(props, propName, componentName, ...rest) {\n    if (propName in props) {\n      if (!warnedAboutDefiningBoth && altPropName in props) {\n        logWarning(\n          `Do not define both the '${propName}' and '${altPropName}' props.`\n        );\n        warnedAboutDefiningBoth = true;\n      }\n      return propType.isRequired(props, propName, componentName, ...rest);\n    }\n    if (!(altPropName in props)) {\n      return new Error(\n        `If the '${altPropName}' prop is not defined, '${propName}' must be.`\n      );\n    }\n  }\n  return validate;\n}\n\nexport const controlKeyword = PropTypes.oneOf([\n  'playpause',\n  'backskip',\n  'forwardskip',\n  'volume',\n  'mute',\n  'repeat',\n  'shuffle',\n  'progress',\n  'progressdisplay',\n  'fullscreen',\n  'spacer'\n]);\n\nexport const control = PropTypes.oneOfType([PropTypes.func, controlKeyword]);\n\nexport const crossOriginAttribute = PropTypes.oneOf([\n  'anonymous',\n  'use-credentials'\n]);\n\nexport const repeatStrategy = PropTypes.oneOf(repeatStrategyOptions);\n\nexport const mediaSource = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired\n});\n\nexport const mediaSessionAction = PropTypes.oneOf([\n  'play',\n  'pause',\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n]);\n\nexport const mediaSessionArtwork = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  sizes: PropTypes.string,\n  type: PropTypes.string\n});\n\nexport const track = PropTypes.shape({\n  url: requiredOnlyUnlessHasProp(PropTypes.string, 'sources'),\n  sources: requiredOnlyUnlessHasProp(\n    PropTypes.arrayOf(mediaSource.isRequired),\n    'url'\n  ),\n  title: PropTypes.string.isRequired,\n  artist: PropTypes.string,\n  album: PropTypes.string,\n  artwork: PropTypes.arrayOf(mediaSessionArtwork.isRequired),\n  meta: PropTypes.object\n});\n\nexport const progressDirection = PropTypes.oneOf([\n  'left',\n  'right',\n  'up',\n  'down'\n]);\n\nexport const seekMode = PropTypes.oneOf(['paused', 'immediate', 'onrelease']);\n\nexport function aspectRatio(props, propName) {\n  const prop = props[propName];\n  if (prop === undefined) {\n    return;\n  }\n  if (\n    typeof prop !== 'string' ||\n    prop.split(':').length !== 2 ||\n    prop.split(':').some(isNaN)\n  ) {\n    return new Error(\n      `The ${propName} prop should be a string of the form 'x:y'. Example: 16:9`\n    );\n  }\n}\n","const loopchange = 'loopchange';\nconst srcrequest = 'srcrequest';\n\nfunction createCustomMediaElement() {\n  const media = document.createElement('video');\n  new MutationObserver(() => {\n    media.dispatchEvent(new Event(loopchange));\n  }).observe(media, {\n    attributes: true,\n    attributeFilter: ['loop']\n  });\n  // Don't let the media src property get modified directly.\n  // Instead, when it does get set, dispatch an event to be\n  // handled in a way that doesn't conflict with the loaded\n  // playlist.\n  Object.defineProperty(media, 'src', {\n    get: () => media.currentSrc,\n    set: src => {\n      const e = new Event(srcrequest);\n      e.srcRequested = src;\n      media.dispatchEvent(e);\n    }\n  });\n  return media;\n}\n\nexport default createCustomMediaElement;\n","/* ShuffleManager\n *\n * Manages navigation throughout a list which is:\n * - Sourced from another provided list\n * - In random order (except to avoid consecutive duplicates)\n * - Extended endlessly on-the-fly, as needed\n * - Able to have future history overwritten by non-random choices\n * - Able to swap source lists and maintain shuffle order for common members\n */\n\nexport class ShuffleManager {\n  constructor(list, options = {}) {\n    this._list = list;\n    this._forwardStack = [];\n    this._backStack = [];\n    this._currentItem = undefined;\n\n    this._allowBackShuffle = Boolean(options.allowBackShuffle);\n  }\n\n  findNextItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._forwardStack,\n      this._backStack,\n      this._currentItem,\n      true\n    );\n    return this._currentItem;\n  }\n\n  findPreviousItem(currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    this._currentItem = _findNextItem(\n      this._list,\n      this._backStack,\n      this._forwardStack,\n      this._currentItem,\n      this._allowBackShuffle\n    );\n    return this._currentItem;\n  }\n\n  pickNextItem(index, currentIndex) {\n    if (currentIndex !== undefined) {\n      this.setCurrentIndex(currentIndex);\n    }\n    if (this._list[index] === undefined) {\n      return undefined;\n    }\n    if (this._currentItem !== undefined) {\n      this._backStack.push(this._currentItem);\n    }\n    this._forwardStack.length = 0;\n    this._currentItem = this._list[index];\n    return this._currentItem;\n  }\n\n  setList(list) {\n    this._list = list;\n  }\n\n  setOptions(options) {\n    for (const o of Object.keys(options)) {\n      switch (o) {\n        case 'allowBackShuffle':\n          this[`_${o}`] = Boolean(options[o]);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  setCurrentIndex(currentIndex) {\n    const item = this._list[currentIndex];\n    if (this._currentItem !== item) {\n      this.clear();\n      this._currentItem = item;\n    }\n  }\n\n  clear() {\n    this._forwardStack.length = 0;\n    this._backStack.length = 0;\n    this._currentItem = undefined;\n  }\n}\n\nfunction _goForward(n, forwardStack, backStack, currentItem) {\n  let item = currentItem;\n  for (let i = 0; i < n; i++) {\n    if (!forwardStack.length) {\n      // rollback before erroring (note stack reversal)\n      _goForward(i, backStack, forwardStack, item);\n      throw `Moving ${n} places was not possible!`;\n    }\n    backStack.push(item);\n    item = forwardStack.pop();\n  }\n  return item;\n}\n\nfunction _allItemsMatch(list, item) {\n  if (!list.length) {\n    return false;\n  }\n  for (let i = 0; i < list.length; i++) {\n    if (item !== list[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction _findNextItem(list, forwardStack, backStack, currentItem, allowMore) {\n  let item = currentItem;\n  if (!list.length) {\n    return undefined;\n  }\n  for (let i = 1; i <= forwardStack.length; i++) {\n    if (list.indexOf(forwardStack[forwardStack.length - i]) !== -1) {\n      return _goForward(i, forwardStack, backStack, item);\n    }\n  }\n  if (!allowMore) {\n    return undefined;\n  }\n  if (_allItemsMatch(list, item)) {\n    // we can serve this as our \"next\" item but we\n    // won't modify our history since it's the same.\n    return item;\n  }\n  let nextItem;\n  do {\n    nextItem = list[Math.floor(Math.random() * list.length)];\n  } while (item === nextItem || nextItem === undefined);\n  // if we're skipping items that aren't in our current list we may\n  // have some items in our forwardStack - make sure we move to the front.\n  item = _goForward(forwardStack.length, forwardStack, backStack, item);\n  if (item !== undefined) {\n    backStack.push(item);\n  }\n  return nextItem;\n}\n\nexport default ShuffleManager;\n","function isPlaylistValid(playlist) {\n  return Boolean(playlist && playlist.length);\n}\n\nexport default isPlaylistValid;\n","import isPlaylistValid from './isPlaylistValid';\n\nconst blankSources = [{ src: '' }];\n\nfunction getTrackSources(playlist, index) {\n  if (!isPlaylistValid(playlist)) {\n    return blankSources;\n  }\n  const { sources, url } = playlist[index];\n  if (sources) {\n    return sources.length ? sources : blankSources;\n  }\n  return [{ src: url }];\n}\n\nexport default getTrackSources;\n","import arrayFindIndex from 'array-find-index';\n\nfunction findTrackIndexByUrl(playlist, url) {\n  return arrayFindIndex(playlist, track => {\n    if (track.sources) {\n      return arrayFindIndex(track.sources, source => source.src === url) !== -1;\n    }\n    return track.url && url === track.url;\n  });\n}\n\nexport default findTrackIndexByUrl;\n","import getTrackSources from './getTrackSources';\n\n// collapses playlist into flat list containing\n// the first source url for each track\nfunction getSourceList(playlist) {\n  return (playlist || []).map((_, i) => getTrackSources(playlist, i)[0].src);\n}\n\nexport default getSourceList;\n","function getTimeRangesArray(timeRangesObj) {\n  const timeRangesArray = Array(timeRangesObj.length);\n  for (let i = 0; i < timeRangesObj.length; i++) {\n    timeRangesArray[i] = {\n      start: timeRangesObj.start(i),\n      end: timeRangesObj.end(i)\n    };\n  }\n  return timeRangesArray;\n}\n\nexport default getTimeRangesArray;\n","function getRepeatStrategy(loop, cycle) {\n  if (loop) {\n    return 'track';\n  }\n  if (cycle) {\n    return 'playlist';\n  }\n  return 'none';\n}\n\nexport default getRepeatStrategy;\n","function convertToNumberWithinIntervalBounds(number, min, max) {\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n  return Math.max(min, Math.min(number, max));\n}\n\nexport default convertToNumberWithinIntervalBounds;\n","import React, { Component, Fragment, createElement } from 'react';\nimport PropTypes from 'prop-types';\nimport arrayFindIndex from 'array-find-index';\n\nimport PlayerContext from './PlayerContext';\nimport GroupContext from './GroupContext';\nimport * as PlayerPropTypes from './PlayerPropTypes';\nimport createCustomMediaElement from './factories/createCustomMediaElement';\nimport ShuffleManager from './utils/ShuffleManager';\nimport { getStateSnapshot, restoreStateFromSnapshot } from './utils/snapshot';\nimport getSourceList from './utils/getSourceList';\nimport getTrackSources from './utils/getTrackSources';\nimport getTimeRangesArray from './utils/getTimeRangesArray';\nimport findTrackIndexByUrl from './utils/findTrackIndexByUrl';\nimport isPlaylistValid from './utils/isPlaylistValid';\nimport getRepeatStrategy from './utils/getRepeatStrategy';\nimport convertToNumberWithinIntervalBounds from './utils/convertToNumberWithinIntervalBounds';\nimport { logError, logWarning } from './utils/console';\nimport { repeatStrategyOptions } from './constants';\n\nfunction playErrorHandler(err) {\n  logError(err);\n  if (err.name === 'NotAllowedError') {\n    const warningMessage =\n      'Media playback failed at ' +\n      new Date().toLocaleTimeString() +\n      '! (Perhaps autoplay is disabled in this browser.)';\n    logWarning(warningMessage);\n  }\n}\n\n// Existing Media Session API implementations have default handlers\n// for play/pause, and may yield unexpected behavior if custom\n// play/pause handlers are defined - so let's leave them be.\nconst supportableMediaSessionActions = [\n  'previoustrack',\n  'nexttrack',\n  'seekbackward',\n  'seekforward'\n];\n\nconst defaultState = {\n  // indicates whether media player should be paused\n  paused: true,\n  // elapsed time for active track, in seconds\n  currentTime: 0,\n  // The most recent targeted time, in seconds, for seek preview\n  seekPreviewTime: 0,\n  /* true if the user is currently dragging the mouse\n   * to seek a new track position\n   */\n  seekInProgress: false,\n  /* true if media was playing when seek previewing began,\n   * it was paused, and it should be resumed on seek\n   * complete\n   */\n  awaitingResumeOnSeekComplete: false,\n  // the duration in seconds of the loaded track\n  duration: 0,\n  // array describing the buffered ranges in the loaded track\n  bufferedRanges: [],\n  // array describing the already-played ranges in the loaded track\n  playedRanges: [],\n  // array describing the seekable ranges in the loaded track\n  seekableRanges: [],\n  // true if the media is currently stalled pending data buffering\n  stalled: false,\n  // true if the active track should play on the next componentDidUpdate\n  awaitingPlay: false\n};\n\n// assumes playlist is valid\nfunction getGoToTrackState({\n  prevState,\n  index,\n  shouldPlay = true,\n  shouldForceLoad = false\n}) {\n  const isNewTrack = prevState.activeTrackIndex !== index;\n  return {\n    activeTrackIndex: index,\n    trackLoading: isNewTrack,\n    currentTime: 0,\n    loop: isNewTrack || shouldForceLoad ? false : prevState.loop,\n    awaitingPlay: Boolean(shouldPlay),\n    paused: !shouldPlay,\n    awaitingForceLoad: Boolean(shouldForceLoad)\n  };\n}\n\nfunction setMediaElementSources(mediaElement, sources) {\n  // remove current sources\n  let firstChild;\n  while ((firstChild = mediaElement.firstChild)) {\n    mediaElement.removeChild(firstChild);\n  }\n  // add new sources\n  for (const source of sources) {\n    const sourceElement = document.createElement('source');\n    sourceElement.src = source.src;\n    if (source.type) {\n      sourceElement.type = source.type;\n    }\n    mediaElement.appendChild(sourceElement);\n  }\n  // cancel playback and re-scan new sources\n  mediaElement.load();\n}\n\n/**\n * Wraps an area which shares a common [`playerContext`](#playercontext)\n */\nexport class PlayerContextProvider extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      ...defaultState,\n      // index matching requested track (whether track has loaded or not)\n      activeTrackIndex: convertToNumberWithinIntervalBounds(\n        props.startingTrackIndex,\n        0\n      ),\n      // whether we're waiting on loading metadata for the active track\n      trackLoading: isPlaylistValid(props.playlist),\n      // the current timestamp on the active track in seconds\n      currentTime: convertToNumberWithinIntervalBounds(props.startingTime, 0),\n      // the latest volume of the media, between 0 and 1.\n      volume: convertToNumberWithinIntervalBounds(props.defaultVolume, 0, 1),\n      // true if the media has been muted\n      muted: props.defaultMuted,\n      // whether to loop the active track\n      loop: props.defaultRepeatStrategy === 'track',\n      // true if playlist should continue at start after completion\n      cycle: props.defaultRepeatStrategy === 'playlist',\n      // whether to randomly pick next track from playlist after one finishes\n      shuffle: props.defaultShuffle,\n      // Rate at which media should be played. 1.0 is normal speed.\n      playbackRate: props.defaultPlaybackRate,\n      // true if user is currently dragging mouse to change the volume\n      setVolumeInProgress: false,\n      // initialize awaitingPlay from autoplay prop\n      awaitingPlay: props.autoplay && isPlaylistValid(props.playlist),\n      awaitingForceLoad: false,\n      // playlist prop copied to state (for getDerivedStateFromProps)\n      __playlist__: props.playlist,\n      // load overrides from previously-captured state snapshot\n      ...(props.initialStateSnapshot\n        ? restoreStateFromSnapshot(props.initialStateSnapshot, props)\n        : {})\n    };\n\n    // volume at last time we were unmuted and not actively setting volume\n    this.lastStableVolume = this.state.volume;\n\n    // used to keep track of play history when we are shuffling\n    this.shuffler = new ShuffleManager(getSourceList(props.playlist), {\n      allowBackShuffle: props.allowBackShuffle\n    });\n\n    // html media element used for playback\n    this.media = null;\n\n    this.videoHostElementList = [];\n    this.videoHostOccupiedCallbacks = new Map();\n    this.videoHostVacatedCallbacks = new Map();\n\n    // bind callback methods to pass to descendant elements\n    this.togglePause = this.togglePause.bind(this);\n    this.selectTrackIndex = this.selectTrackIndex.bind(this);\n    this.forwardSkip = this.forwardSkip.bind(this);\n    this.backSkip = this.backSkip.bind(this);\n    this.seekPreview = this.seekPreview.bind(this);\n    this.seekComplete = this.seekComplete.bind(this);\n    this.setVolume = this.setVolume.bind(this);\n    this.setVolumeComplete = this.setVolumeComplete.bind(this);\n    this.toggleMuted = this.toggleMuted.bind(this);\n    this.toggleShuffle = this.toggleShuffle.bind(this);\n    this.setRepeatStrategy = this.setRepeatStrategy.bind(this);\n    this.setPlaybackRate = this.setPlaybackRate.bind(this);\n    this.registerVideoHostElement = this.registerVideoHostElement.bind(this);\n    this.renderVideoIntoHostElement = this.renderVideoIntoHostElement.bind(\n      this\n    );\n    this.unregisterVideoHostElement = this.unregisterVideoHostElement.bind(\n      this\n    );\n    this.updateVideoHostElement = this.updateVideoHostElement.bind(this);\n\n    // bind media event handlers\n    this.handleMediaPlay = this.handleMediaPlay.bind(this);\n    this.handleMediaPause = this.handleMediaPause.bind(this);\n    this.handleMediaSrcrequest = this.handleMediaSrcrequest.bind(this);\n    this.handleMediaEnded = this.handleMediaEnded.bind(this);\n    this.handleMediaStalled = this.handleMediaStalled.bind(this);\n    this.handleMediaCanplaythrough = this.handleMediaCanplaythrough.bind(this);\n    this.handleMediaTimeupdate = this.handleMediaTimeupdate.bind(this);\n    this.handleMediaLoadedmetadata = this.handleMediaLoadedmetadata.bind(this);\n    this.handleMediaVolumechange = this.handleMediaVolumechange.bind(this);\n    this.handleMediaDurationchange = this.handleMediaDurationchange.bind(this);\n    this.handleMediaProgress = this.handleMediaProgress.bind(this);\n    this.handleMediaLoopchange = this.handleMediaLoopchange.bind(this);\n    this.handleMediaRatechange = this.handleMediaRatechange.bind(this);\n  }\n\n  componentDidMount() {\n    const media = (this.media = createCustomMediaElement());\n\n    const {\n      defaultPlaybackRate,\n      crossOrigin,\n      playlist,\n      autoplayDelayInSeconds,\n      mediaElementRef,\n      getPosterImageForTrack,\n      onActiveTrackUpdate\n    } = this.props;\n    const {\n      volume,\n      muted,\n      playbackRate,\n      loop,\n      activeTrackIndex,\n      awaitingPlay\n    } = this.state;\n\n    // initialize media properties\n    // We used to set currentTime here.. now waiting for loadedmetadata.\n    // This avoids an issue where some browsers ignore or delay currentTime\n    // updates when in the HAVE_NOTHING state.\n    media.defaultPlaybackRate = defaultPlaybackRate;\n    media.crossOrigin = crossOrigin;\n    media.volume = volume;\n    media.muted = muted;\n    media.playbackRate = playbackRate;\n    media.loop = loop;\n    media.setAttribute('playsinline', '');\n    media.setAttribute('webkit-playsinline', '');\n    media.setAttribute('preload', 'metadata');\n    media.setAttribute(\n      'poster',\n      getPosterImageForTrack(playlist[activeTrackIndex])\n    );\n\n    // add listeners for media events\n    media.addEventListener('play', this.handleMediaPlay);\n    media.addEventListener('pause', this.handleMediaPause);\n    media.addEventListener('ended', this.handleMediaEnded);\n    media.addEventListener('stalled', this.handleMediaStalled);\n    media.addEventListener('canplaythrough', this.handleMediaCanplaythrough);\n    media.addEventListener('timeupdate', this.handleMediaTimeupdate);\n    media.addEventListener('loadedmetadata', this.handleMediaLoadedmetadata);\n    media.addEventListener('volumechange', this.handleMediaVolumechange);\n    media.addEventListener('durationchange', this.handleMediaDurationchange);\n    media.addEventListener('progress', this.handleMediaProgress);\n    media.addEventListener('ratechange', this.handleMediaRatechange);\n    // add listeners for special events\n    media.addEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.addEventListener('loopchange', this.handleMediaLoopchange);\n\n    // set source elements for current track\n    setMediaElementSources(media, getTrackSources(playlist, activeTrackIndex));\n\n    // initially mount media element in the hidden container (this may change)\n    this.mediaContainer.appendChild(media);\n\n    if (awaitingPlay) {\n      this.setState({\n        awaitingPlay: false\n      });\n      this.delayTimeout = setTimeout(() => {\n        this.togglePause(false);\n      }, autoplayDelayInSeconds * 1000);\n    }\n\n    if (mediaElementRef) {\n      mediaElementRef(media);\n    }\n\n    if (onActiveTrackUpdate) {\n      onActiveTrackUpdate(playlist[activeTrackIndex], activeTrackIndex);\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const newPlaylist = nextProps.playlist;\n\n    if (newPlaylist === prevState.__playlist__) {\n      // reference comparison is equal so we'll\n      // assume the playlist is unchanged.\n      return null;\n    }\n\n    const baseNewState = {\n      __playlist__: newPlaylist\n    };\n\n    // check if the new playlist is invalid\n    if (!isPlaylistValid(newPlaylist)) {\n      return {\n        ...defaultState,\n        ...baseNewState,\n        activeTrackIndex: 0,\n        trackLoading: false\n      };\n    }\n\n    // check if the activeTrackIndex doesn't need to be updated\n    const prevSources = getTrackSources(\n      prevState.__playlist__,\n      prevState.activeTrackIndex\n    );\n\n    if (newPlaylist[prevState.activeTrackIndex]) {\n      // the sources if we stay on the same track index\n      const currentSources = getTrackSources(\n        newPlaylist,\n        prevState.activeTrackIndex\n      );\n      // non-comprehensive but probably accurate check\n      if (prevSources[0].src === currentSources[0].src) {\n        // our active track index already matches\n        return baseNewState;\n      }\n    }\n\n    /* if the track we're already playing is in the new playlist, update the\n     * activeTrackIndex.\n     */\n    const newTrackIndex = findTrackIndexByUrl(newPlaylist, prevSources[0].src);\n    if (newTrackIndex !== -1) {\n      return {\n        ...baseNewState,\n        activeTrackIndex: newTrackIndex\n      };\n    }\n\n    // if not, then load the first track in the new playlist, and pause.\n    return {\n      ...baseNewState,\n      ...getGoToTrackState({ prevState, index: 0, shouldPlay: false })\n    };\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.media.defaultPlaybackRate = this.props.defaultPlaybackRate;\n    this.media.crossOrigin = this.props.crossOrigin;\n\n    this.shuffler.setList(getSourceList(this.props.playlist));\n    this.shuffler.setOptions({\n      allowBackShuffle: this.props.allowBackShuffle\n    });\n\n    const prevSources = getTrackSources(\n      prevProps.playlist,\n      prevState.activeTrackIndex\n    );\n    const newSources = getTrackSources(\n      this.props.playlist,\n      this.state.activeTrackIndex\n    );\n    const prevTrack = prevProps.playlist[prevState.activeTrackIndex];\n    const newTrack = this.props.playlist[this.state.activeTrackIndex];\n    if (\n      this.state.awaitingForceLoad ||\n      prevSources[0].src !== newSources[0].src\n    ) {\n      setMediaElementSources(this.media, newSources);\n      this.media.setAttribute(\n        'poster',\n        this.props.getPosterImageForTrack(newTrack)\n      );\n      this.setState({\n        awaitingForceLoad: false\n      });\n      if (!this.state.shuffle) {\n        // after toggling off shuffle, we defer clearing the shuffle\n        // history until we actually change tracks - if the user quickly\n        // toggles  shuffle off then back on again, we don't want to have\n        // lost our history.\n        this.shuffler.clear();\n      }\n    }\n\n    if (this.props.onActiveTrackUpdate && prevTrack !== newTrack) {\n      this.props.onActiveTrackUpdate(newTrack, this.state.activeTrackIndex);\n    }\n\n    if (prevProps !== this.props && !this.media.paused) {\n      // update running media session based on new props\n      this.stealMediaSession();\n    }\n\n    if (this.state.awaitingPlay) {\n      this.setState({\n        awaitingPlay: false\n      });\n      // media.currentSrc is updated asynchronously so we should\n      // play async to avoid weird intermediate state issues\n      setTimeout(() => {\n        this.togglePause(false);\n      });\n    }\n\n    clearTimeout(this.snapshotUpdateTimeout);\n    this.snapshotUpdateTimeout = setTimeout(() => {\n      if (this.props.onStateSnapshot) {\n        this.props.onStateSnapshot(getStateSnapshot(this.state));\n      }\n    }, 100);\n  }\n\n  componentWillUnmount() {\n    const { media } = this;\n    // remove listeners for media events\n    media.removeEventListener('play', this.handleMediaPlay);\n    media.removeEventListener('pause', this.handleMediaPause);\n    media.removeEventListener('ended', this.handleMediaEnded);\n    media.removeEventListener('stalled', this.handleMediaStalled);\n    media.removeEventListener('canplaythrough', this.handleMediaCanplaythrough);\n    media.removeEventListener('timeupdate', this.handleMediaTimeupdate);\n    media.removeEventListener('loadedmetadata', this.handleMediaLoadedmetadata);\n    media.removeEventListener('volumechange', this.handleMediaVolumechange);\n    media.removeEventListener('durationchange', this.handleMediaDurationchange);\n    media.removeEventListener('progress', this.handleMediaProgress);\n    media.removeEventListener('ratechange', this.handleMediaRatechange);\n    // remove special event listeners on the media element\n    media.removeEventListener('srcrequest', this.handleMediaSrcrequest);\n    media.removeEventListener('loopchange', this.handleMediaLoopchange);\n\n    clearTimeout(this.gapLengthTimeout);\n    clearTimeout(this.delayTimeout);\n  }\n\n  stealMediaSession() {\n    if (\n      // eslint-disable-next-line no-undef\n      !(window.MediaSession && navigator.mediaSession instanceof MediaSession)\n    ) {\n      return;\n    }\n    // eslint-disable-next-line no-undef\n    navigator.mediaSession.metadata = new MediaMetadata(\n      this.props.playlist[this.state.activeTrackIndex]\n    );\n    supportableMediaSessionActions\n      .map(action => {\n        if (this.props.supportedMediaSessionActions.indexOf(action) === -1) {\n          return null;\n        }\n        const seekLength = this.props.mediaSessionSeekLengthInSeconds;\n        switch (action) {\n          case 'play':\n            return this.togglePause.bind(this, false);\n          case 'pause':\n            return this.togglePause.bind(this, true);\n          case 'previoustrack':\n            return this.backSkip;\n          case 'nexttrack':\n            return this.forwardSkip;\n          case 'seekbackward':\n            return () => (this.media.currentTime -= seekLength);\n          case 'seekforward':\n            return () => (this.media.currentTime += seekLength);\n          default:\n            return undefined;\n        }\n      })\n      .forEach((handler, i) => {\n        navigator.mediaSession.setActionHandler(\n          supportableMediaSessionActions[i],\n          handler\n        );\n      });\n  }\n\n  registerVideoHostElement(hostElement, { onHostOccupied, onHostVacated }) {\n    this.videoHostElementList = this.videoHostElementList.concat(hostElement);\n    this.videoHostOccupiedCallbacks.set(hostElement, onHostOccupied);\n    this.videoHostVacatedCallbacks.set(hostElement, onHostVacated);\n  }\n\n  renderVideoIntoHostElement(hostElement) {\n    if (this.videoHostElementList.indexOf(hostElement) === -1) {\n      return;\n    }\n    cancelAnimationFrame(this.videoHostUpdateRaf);\n    this.videoHostUpdateRaf = requestAnimationFrame(() =>\n      this.updateVideoHostElement(hostElement)\n    );\n  }\n\n  unregisterVideoHostElement(hostElement) {\n    this.videoHostElementList = this.videoHostElementList.filter(\n      elem => elem !== hostElement\n    );\n    this.videoHostOccupiedCallbacks.delete(hostElement);\n    this.videoHostVacatedCallbacks.delete(hostElement);\n    if (this.media.parentNode === hostElement) {\n      this.updateVideoHostElement();\n    }\n  }\n\n  updateVideoHostElement(hostElement) {\n    if (!hostElement) {\n      hostElement = this.videoHostElementList[0] || this.mediaContainer;\n    } else {\n      // move hostElement to front of list\n      this.videoHostElementList = [hostElement].concat(\n        this.videoHostElementList.filter(elem => elem !== hostElement)\n      );\n    }\n    const playing = !this.media.paused;\n    const oldHostElement = this.media.parentNode;\n    if (hostElement === oldHostElement) {\n      return;\n    }\n    hostElement.appendChild(this.media);\n    // according to the HTML spec playback should continue, but\n    // some browsers pause the element whenever it is moved around, so\n    // let's make sure playback resumes if that's the case.\n    if (playing && this.media.paused) {\n      this.media.play();\n    }\n    const onVacated = this.videoHostVacatedCallbacks.get(oldHostElement);\n    if (onVacated) {\n      onVacated(this.media);\n    }\n    const onOccupied = this.videoHostOccupiedCallbacks.get(hostElement);\n    if (onOccupied) {\n      onOccupied(this.media);\n    }\n  }\n\n  handleMediaPlay() {\n    this.setState(state => (state.paused === false ? null : { paused: false }));\n    this.stealMediaSession();\n  }\n\n  handleMediaPause() {\n    this.setState(state => (state.paused === true ? null : { paused: true }));\n  }\n\n  handleMediaSrcrequest(e) {\n    const { playlist } = this.props;\n    const sources = getTrackSources(playlist, this.state.activeTrackIndex);\n    if (arrayFindIndex(sources, s => s.src === e.srcRequested) !== -1) {\n      // we're good! nothing to update.\n      return;\n    }\n    // looks like 'src' was set from outside our component.\n    // let's see if we can use it.\n    const newTrackIndex = findTrackIndexByUrl(playlist, e.srcRequested);\n    if (newTrackIndex === -1) {\n      logError(\n        `Source '${e.srcRequested}' does not exist in the loaded playlist. ` +\n          `Make sure you've updated the 'playlist' prop to ` +\n          `PlayerContextProvider before you select this track!`\n      );\n      return;\n    }\n    this.selectTrackIndex(newTrackIndex);\n  }\n\n  handleMediaEnded() {\n    if (this.state.seekInProgress) {\n      // nothing to do if we're in the middle of a seek\n      // (this can happen if we're in seekMode: immediate)\n      return;\n    }\n    clearTimeout(this.gapLengthTimeout);\n    const { playlist, loadFirstTrackOnPlaylistComplete } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    const { cycle, activeTrackIndex } = this.state;\n    if (!cycle && activeTrackIndex + 1 >= playlist.length) {\n      if (loadFirstTrackOnPlaylistComplete) {\n        this.goToTrack({ index: 0, shouldPlay: false, shouldForceLoad: true });\n      }\n      return;\n    }\n    this.gapLengthTimeout = setTimeout(\n      this.forwardSkip,\n      this.props.gapLengthInSeconds * 1000\n    );\n  }\n\n  handleMediaStalled() {\n    this.setState(state => (state.stalled === true ? null : { stalled: true }));\n  }\n\n  handleMediaCanplaythrough() {\n    this.setState(\n      state => (state.stalled === false ? null : { stalled: false })\n    );\n  }\n\n  handleMediaTimeupdate() {\n    const { currentTime, played } = this.media;\n    if (this.state.trackLoading) {\n      // correct currentTime to preset, if applicable, during load\n      this.media.currentTime = this.state.currentTime;\n      return;\n    }\n    this.setState({\n      currentTime,\n      playedRanges: getTimeRangesArray(played)\n    });\n  }\n\n  handleMediaLoadedmetadata() {\n    if (this.media.currentTime !== this.state.currentTime) {\n      this.media.currentTime = this.state.currentTime;\n    }\n    this.setState(\n      state => (state.trackLoading === false ? null : { trackLoading: false })\n    );\n  }\n\n  handleMediaVolumechange() {\n    const { volume, muted } = this.media;\n    this.setState({ volume, muted });\n  }\n\n  handleMediaDurationchange() {\n    const { duration } = this.media;\n    this.setState({ duration });\n  }\n\n  handleMediaProgress() {\n    this.setState({\n      bufferedRanges: getTimeRangesArray(this.media.buffered),\n      seekableRanges: getTimeRangesArray(this.media.seekable)\n    });\n  }\n\n  handleMediaLoopchange() {\n    const { loop } = this.media;\n    this.setState(state => (state.loop === loop ? null : { loop }));\n  }\n\n  handleMediaRatechange() {\n    const { playbackRate } = this.media;\n    this.setState(\n      state => (state.playbackRate === playbackRate ? null : { playbackRate })\n    );\n  }\n\n  togglePause(value) {\n    clearTimeout(this.delayTimeout);\n    const pause = typeof value === 'boolean' ? value : !this.state.paused;\n    if (pause) {\n      this.media.pause();\n      return;\n    }\n    if (!this.media.currentSrc) {\n      return;\n    }\n    try {\n      const playPromise = this.media.play();\n      if (playPromise && typeof playPromise.catch === 'function') {\n        playPromise\n          .catch(err => {\n            // AbortError is pretty much always called because we're skipping\n            // tracks quickly or hitting pause before a track has a chance to\n            // play. It's pretty safe to just ignore these error messages.\n            if (err.name !== 'AbortError') {\n              return Promise.reject(err);\n            }\n          })\n          .catch(playErrorHandler);\n      }\n    } catch (err) {\n      playErrorHandler(err);\n    }\n  }\n\n  // assumes playlist is valid - don't call without checking\n  goToTrack(args) {\n    clearTimeout(this.delayTimeout);\n    this.setState(prevState => getGoToTrackState({ prevState, ...args }));\n  }\n\n  selectTrackIndex(index) {\n    const { playlist } = this.props;\n    if (!isPlaylistValid(playlist)) {\n      return;\n    }\n    if (index < 0 || index > playlist.length) {\n      logWarning(`Playlist index ${index} is out of bounds!`);\n      return;\n    }\n    if (this.state.shuffle) {\n      this.shuffler.pickNextItem(index, this.state.activeTrackIndex);\n    }\n    this.goToTrack({ index });\n  }\n\n  backSkip() {\n    const { playlist, stayOnBackSkipThreshold } = this.props;\n    const { media } = this;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      media.currentTime >= stayOnBackSkipThreshold ||\n      (!cycle && activeTrackIndex < 1)\n    ) {\n      media.currentTime = 0;\n      return;\n    }\n    let index;\n    if (shuffle) {\n      const previousItem = this.shuffler.findPreviousItem(activeTrackIndex);\n      if (previousItem === undefined) {\n        // if we aren't allowing backShuffle then we'll hit a stopping point.\n        media.currentTime = 0;\n        return;\n      }\n      index = findTrackIndexByUrl(playlist, previousItem);\n    } else {\n      index = activeTrackIndex - 1;\n      if (index < 0) {\n        index = playlist.length - 1;\n      }\n    }\n    this.goToTrack({ index, shouldForceLoad: true });\n  }\n\n  forwardSkip() {\n    const { playlist } = this.props;\n    const { cycle, activeTrackIndex, shuffle } = this.state;\n    if (\n      !isPlaylistValid(playlist) ||\n      (!cycle && activeTrackIndex + 1 >= playlist.length)\n    ) {\n      return;\n    }\n    let index;\n    if (shuffle) {\n      index = findTrackIndexByUrl(\n        playlist,\n        this.shuffler.findNextItem(activeTrackIndex)\n      );\n    } else {\n      index = activeTrackIndex + 1;\n      if (index >= playlist.length) {\n        index = 0;\n      }\n    }\n    this.goToTrack({ index, shouldForceLoad: true });\n  }\n\n  seekPreview(targetTime) {\n    if (!isPlaylistValid(this.props.playlist)) {\n      return;\n    }\n    const baseStateUpdate = {\n      seekPreviewTime: targetTime,\n      seekInProgress: true\n    };\n    switch (this.props.seekMode) {\n      case 'paused':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true\n        }));\n        this.media.currentTime = targetTime;\n        if (!this.state.paused) {\n          this.togglePause(true);\n        }\n        break;\n      case 'immediate':\n        this.setState(({ paused, awaitingResumeOnSeekComplete }) => ({\n          ...baseStateUpdate,\n          awaitingResumeOnSeekComplete: paused\n            ? awaitingResumeOnSeekComplete\n            : true\n        }));\n        this.media.currentTime = targetTime;\n        if (this.state.awaitingResumeOnSeekComplete && !this.media.ended) {\n          // if we earlier encountered an 'ended' state,\n          // un-pausing becomes necessary to resume playback\n          this.togglePause(false);\n        }\n        break;\n      case 'onrelease':\n        this.setState(baseStateUpdate);\n        break;\n    }\n  }\n\n  seekComplete(targetTime) {\n    const { seekPreviewTime, awaitingResumeOnSeekComplete } = this.state;\n    const baseStateUpdate = {\n      seekInProgress: false,\n      awaitingResumeOnSeekComplete: false\n    };\n    const currentTime =\n      typeof targetTime === 'number' ? targetTime : seekPreviewTime;\n\n    if (isNaN(currentTime)) {\n      this.setState(baseStateUpdate);\n      return;\n    }\n    this.setState({\n      ...baseStateUpdate,\n      /* we'll update currentTime on the media listener hook anyway,\n       * but that might not happen for a bit... so the optimistic update\n       * helps us avoid the progress bar jumping around and confusing the user.\n       * https://github.com/benwiley4000/cassette/issues/209\n       */\n      currentTime\n    });\n    this.media.currentTime = currentTime;\n    if (awaitingResumeOnSeekComplete) {\n      if (this.media.ended) {\n        this.forwardSkip();\n      } else {\n        this.togglePause(false);\n      }\n    }\n  }\n\n  setVolume(volume, inProgress = true) {\n    if (inProgress && !this.state.setVolumeInProgress) {\n      this.setState({\n        setVolumeInProgress: true\n      });\n    }\n    const volumeInBounds = convertToNumberWithinIntervalBounds(volume, 0, 1);\n    this.media.muted = volumeInBounds === 0 ? true : false;\n    this.media.volume = volumeInBounds;\n  }\n\n  setVolumeComplete(volume) {\n    if (typeof volume === 'number') {\n      this.setVolume(volume, false);\n    }\n    this.setState({\n      setVolumeInProgress: false\n    });\n    if (!this.media.muted) {\n      this.lastStableVolume = this.media.volume;\n    }\n  }\n\n  toggleMuted(value) {\n    const muted = typeof value === 'boolean' ? value : !this.state.muted;\n    this.media.muted = muted;\n    if (!muted) {\n      this.media.volume = this.lastStableVolume;\n    }\n  }\n\n  toggleShuffle(value) {\n    const shuffle = typeof value === 'boolean' ? value : !this.state.shuffle;\n    this.setState({ shuffle });\n  }\n\n  setRepeatStrategy(repeatStrategy) {\n    if (repeatStrategyOptions.indexOf(repeatStrategy) === -1) {\n      logWarning(\n        'repeatStrategy \"' +\n          repeatStrategy +\n          '\" is not one of: ' +\n          repeatStrategyOptions.split(', ') +\n          '.'\n      );\n      return;\n    }\n    switch (repeatStrategy) {\n      case 'track':\n        // state update is automatic\n        this.media.loop = true;\n        break;\n      case 'playlist':\n        this.setState({\n          loop: false,\n          cycle: true\n        });\n        this.media.loop = false;\n        break;\n      case 'none':\n        this.setState({\n          loop: false,\n          cycle: false\n        });\n        this.media.loop = false;\n        break;\n    }\n  }\n\n  setPlaybackRate(rate) {\n    this.media.playbackRate = rate;\n  }\n\n  getControlProps() {\n    const { props, state } = this;\n    const playerContext = {\n      playlist: props.playlist,\n      activeTrackIndex: state.activeTrackIndex,\n      trackLoading: state.trackLoading,\n      paused: state.paused,\n      currentTime: state.currentTime,\n      seekPreviewTime: state.seekPreviewTime,\n      seekInProgress: state.seekInProgress,\n      awaitingResumeOnSeekComplete: state.awaitingResumeOnSeekComplete,\n      duration: state.duration,\n      bufferedRanges: state.bufferedRanges,\n      playedRanges: state.playedRanges,\n      seekableRanges: state.seekableRanges,\n      volume: state.volume,\n      muted: state.muted,\n      shuffle: state.shuffle,\n      stalled: state.stalled,\n      playbackRate: state.playbackRate,\n      setVolumeInProgress: state.setVolumeInProgress,\n      repeatStrategy: getRepeatStrategy(state.loop, state.cycle),\n      registerVideoHostElement: this.registerVideoHostElement,\n      renderVideoIntoHostElement: this.renderVideoIntoHostElement,\n      unregisterVideoHostElement: this.unregisterVideoHostElement,\n      onTogglePause: this.togglePause,\n      onSelectTrackIndex: this.selectTrackIndex,\n      onBackSkip: this.backSkip,\n      onForwardSkip: this.forwardSkip,\n      onSeekPreview: this.seekPreview,\n      onSeekComplete: this.seekComplete,\n      onSetVolume: this.setVolume,\n      onSetVolumeComplete: this.setVolumeComplete,\n      onToggleMuted: this.toggleMuted,\n      onToggleShuffle: this.toggleShuffle,\n      onSetRepeatStrategy: this.setRepeatStrategy,\n      onSetPlaybackRate: this.setPlaybackRate\n    };\n    if (this.playerContext) {\n      // only update this.playerContext if something has changed\n      for (const key of Object.keys(this.playerContext)) {\n        if (playerContext[key] !== this.playerContext[key]) {\n          this.playerContext = playerContext;\n          break;\n        }\n      }\n    } else {\n      // first time - nothing to compare\n      this.playerContext = playerContext;\n    }\n    return this.playerContext;\n  }\n\n  render() {\n    const playerContext = this.getControlProps();\n    return (\n      <Fragment>\n        <div ref={elem => (this.mediaContainer = elem)} hidden />\n        <PlayerContext.Provider value={playerContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(playerContext)\n            : this.props.children}\n        </PlayerContext.Provider>\n      </Fragment>\n    );\n  }\n}\n\nPlayerContextProvider.propTypes = {\n  playlist: PropTypes.arrayOf(PlayerPropTypes.track.isRequired).isRequired,\n  autoplay: PropTypes.bool.isRequired,\n  autoplayDelayInSeconds: PropTypes.number.isRequired,\n  gapLengthInSeconds: PropTypes.number.isRequired,\n  crossOrigin: PlayerPropTypes.crossOriginAttribute,\n  defaultVolume: PropTypes.number.isRequired,\n  defaultMuted: PropTypes.bool,\n  defaultRepeatStrategy: PlayerPropTypes.repeatStrategy.isRequired,\n  defaultShuffle: PropTypes.bool,\n  defaultPlaybackRate: PropTypes.number.isRequired,\n  startingTime: PropTypes.number.isRequired,\n  startingTrackIndex: PropTypes.number.isRequired,\n  loadFirstTrackOnPlaylistComplete: PropTypes.bool,\n  seekMode: PlayerPropTypes.seekMode.isRequired,\n  maintainPlaybackRate: PropTypes.bool.isRequired,\n  allowBackShuffle: PropTypes.bool,\n  stayOnBackSkipThreshold: PropTypes.number.isRequired,\n  supportedMediaSessionActions: PropTypes.arrayOf(\n    PlayerPropTypes.mediaSessionAction.isRequired\n  ).isRequired,\n  mediaSessionSeekLengthInSeconds: PropTypes.number.isRequired,\n  mediaElementRef: PropTypes.func,\n  initialStateSnapshot: PropTypes.shape({\n    __unstable__: PropTypes.object.isRequired\n  }),\n  onStateSnapshot: PropTypes.func,\n  onActiveTrackUpdate: PropTypes.func,\n  getPosterImageForTrack: PropTypes.func.isRequired,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nPlayerContextProvider.defaultProps = {\n  autoplay: false,\n  autoplayDelayInSeconds: 0,\n  gapLengthInSeconds: 0,\n  defaultVolume: 1,\n  defaultMuted: false,\n  defaultRepeatStrategy: 'playlist',\n  defaultShuffle: false,\n  defaultPlaybackRate: 1,\n  startingTime: 0,\n  startingTrackIndex: 0,\n  loadFirstTrackOnPlaylistComplete: true,\n  seekMode: 'immediate',\n  maintainPlaybackRate: false,\n  allowBackShuffle: false,\n  stayOnBackSkipThreshold: 5,\n  supportedMediaSessionActions: ['play', 'pause', 'previoustrack', 'nexttrack'],\n  mediaSessionSeekLengthInSeconds: 10,\n  getPosterImageForTrack(track) {\n    return track && track.artwork ? track.artwork[0].src : '';\n  }\n};\n\nexport class PlayerContextGroupMember extends Component {\n  componentDidMount() {\n    this.props.groupContext.registerMediaElement(this.mediaElement);\n  }\n\n  componentWillUnmount() {\n    this.props.groupContext.unregisterMediaElement(this.mediaElement);\n  }\n\n  render() {\n    const { groupContext, props } = this.props;\n    const { mediaElementRef, ...rest } = props;\n    return (\n      <PlayerContextProvider\n        {...groupContext.groupProps}\n        {...rest}\n        mediaElementRef={ref => {\n          if (mediaElementRef) {\n            mediaElementRef(ref);\n          }\n          this.mediaElement = ref;\n        }}\n      />\n    );\n  }\n}\n\nPlayerContextGroupMember.propTypes = {\n  groupContext: PropTypes.shape({\n    groupProps: PropTypes.object.isRequired,\n    registerMediaElement: PropTypes.func.isRequired,\n    unregisterMediaElement: PropTypes.func.isRequired\n  }).isRequired\n};\n\nfunction PlayerContextGroupConsumer(props) {\n  return (\n    <GroupContext.Consumer>\n      {groupContext => {\n        if (!groupContext) {\n          return createElement(PlayerContextProvider, props);\n        }\n        return createElement(PlayerContextGroupMember, {\n          groupContext,\n          props\n        });\n      }}\n    </GroupContext.Consumer>\n  );\n}\n\nexport default PlayerContextGroupConsumer;\n","import isPlaylistValid from './isPlaylistValid';\nimport getTrackSources from './getTrackSources';\nimport findTrackIndexByUrl from './findTrackIndexByUrl';\n\nexport function getStateSnapshot(state) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    __playlist__\n  } = state;\n  return {\n    __unstable__: {\n      paused,\n      currentTime,\n      activeTrackIndex,\n      volume,\n      muted,\n      loop,\n      cycle,\n      shuffle,\n      playbackRate,\n      activeTrackSrc: isPlaylistValid(__playlist__)\n        ? getTrackSources(__playlist__, activeTrackIndex)[0].src\n        : null\n    }\n  };\n}\n\nexport function restoreStateFromSnapshot(snapshot, props) {\n  const {\n    paused,\n    currentTime,\n    activeTrackIndex,\n    volume,\n    muted,\n    loop,\n    cycle,\n    shuffle,\n    playbackRate,\n    activeTrackSrc\n  } = snapshot.__unstable__;\n  const restoredStateValues = {};\n  if (isPlaylistValid(props.playlist) && typeof paused === 'boolean') {\n    // using awaitingPlay instead of paused triggers an animation\n    restoredStateValues.awaitingPlay = !paused;\n  }\n  if (typeof volume === 'number' && volume >= 0 && volume <= 1) {\n    restoredStateValues.volume = volume;\n  }\n  if (typeof muted === 'boolean') {\n    restoredStateValues.muted = muted;\n  }\n  if (typeof loop === 'boolean') {\n    restoredStateValues.loop = loop;\n  }\n  if (typeof cycle === 'boolean') {\n    restoredStateValues.cycle = cycle;\n  }\n  if (typeof shuffle === 'boolean') {\n    restoredStateValues.shuffle = shuffle;\n  }\n  if (typeof playbackRate === 'number') {\n    restoredStateValues.playbackRate = playbackRate;\n  }\n  let useCurrentTime = false;\n  if (\n    typeof activeTrackSrc === 'string' &&\n    typeof activeTrackIndex === 'number' &&\n    activeTrackIndex >= 0\n  ) {\n    // let's try staying on the same track index\n    const currentSrc =\n      props.playlist[activeTrackIndex] &&\n      getTrackSources(props.playlist, activeTrackIndex)[0].src;\n    if (currentSrc && activeTrackSrc === currentSrc) {\n      restoredStateValues.activeTrackIndex = activeTrackIndex;\n      useCurrentTime = true;\n    } else {\n      /* if the track we were playing before is in the new playlist,\n       * update the activeTrackIndex.\n       */\n      const newTrackIndex = findTrackIndexByUrl(props.playlist, activeTrackSrc);\n      if (newTrackIndex !== -1) {\n        restoredStateValues.activeTrackIndex = newTrackIndex;\n        useCurrentTime = true;\n      }\n    }\n  }\n  if (useCurrentTime && typeof currentTime === 'number' && currentTime >= 0) {\n    restoredStateValues.currentTime = currentTime;\n  }\n  return restoredStateValues;\n}\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport GroupContext from './GroupContext';\n\n/**\n * A wrapper which can be used to share configuration among multiple descendant [`PlayerContextProvider`](#playercontextprovider) instances as well as prevent multiple media elements from playing audio simultaneously\n */\nexport class PlayerContextGroup extends Component {\n  constructor(props) {\n    super(props);\n    this.registerMediaElement = this.registerMediaElement.bind(this);\n    this.unregisterMediaElement = this.unregisterMediaElement.bind(this);\n    this.enforceOneMediaSourceOnly = this.enforceOneMediaSourceOnly.bind(this);\n    this.mediaElements = [];\n  }\n\n  registerMediaElement(elem) {\n    this.mediaElements = this.mediaElements.concat(elem);\n    elem.addEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.addEventListener('volumechange', this.enforceOneMediaSourceOnly, true);\n  }\n\n  unregisterMediaElement(elem) {\n    this.mediaElements = this.mediaElements.filter(element => elem !== element);\n    elem.removeEventListener('play', this.enforceOneMediaSourceOnly, true);\n    elem.removeEventListener(\n      'volumechange',\n      this.enforceOneMediaSourceOnly,\n      true\n    );\n  }\n\n  enforceOneMediaSourceOnly(e) {\n    const mediaElement = e.target;\n    const { paused, muted } = mediaElement;\n    if (paused || muted) {\n      return;\n    }\n    for (const element of this.mediaElements) {\n      if (element !== mediaElement && !element.muted) {\n        element.pause();\n      }\n    }\n  }\n\n  render() {\n    return (\n      <GroupContext.Consumer>\n        {groupContext => {\n          const value = groupContext\n            ? {\n                ...groupContext,\n                groupProps: { ...groupContext.groupProps, ...this.props }\n              }\n            : {\n                groupProps: this.props,\n                registerMediaElement: this.registerMediaElement,\n                unregisterMediaElement: this.unregisterMediaElement\n              };\n          return (\n            <GroupContext.Provider value={value}>\n              {this.props.children}\n            </GroupContext.Provider>\n          );\n        }}\n      </GroupContext.Consumer>\n    );\n  }\n}\n\nPlayerContextGroup.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\nexport default PlayerContextGroup;\n","import createSingleGlobalContext from './utils/createSingleGlobalContext';\nimport { logWarning } from './utils/console';\n\nexport default createSingleGlobalContext('FullscreenContext', {\n  fullscreen: false,\n  requestFullscreen() {\n    logWarning(\n      'Fullscreen request ignored since there is no ' +\n        'FullscreenContextProvider ancestor.'\n    );\n  },\n  requestExitFullscreen() {\n    logWarning(\n      'Exit fullscreen request ignored since there is no ' +\n        'FullscreenContextProvider ancestor.'\n    );\n  }\n});\n","import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nimport FullscreenContext from './FullscreenContext';\n\nconst fullscreenStyle = {\n  width: '100%',\n  height: '100%'\n};\n\n/**\n * Wraps an area which should be fullscreen-able\n */\nexport class FullscreenContextProvider extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      fullscreen: false\n    };\n    this.requestFullscreen = this.requestFullscreen.bind(this);\n    this.requestExitFullscreen = this.requestExitFullscreen.bind(this);\n    this.handleFullscreenChange = this.handleFullscreenChange.bind(this);\n    this.fullscreenElement = null;\n  }\n\n  componentDidMount() {\n    document.addEventListener('fullscreenchange', this.handleFullscreenChange);\n    document.addEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.addEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\n      'fullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'webkitfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'mozfullscreenchange',\n      this.handleFullscreenChange\n    );\n    document.removeEventListener(\n      'msfullscreenchange',\n      this.handleFullscreenChange\n    );\n  }\n\n  requestFullscreen() {\n    if (!this.props.fullscreenEnabled) {\n      return;\n    }\n    if (this.fullscreenElement.requestFullscreen) {\n      this.fullscreenElement.requestFullscreen();\n    } else if (this.fullscreenElement.webkitRequestFullscreen) {\n      this.fullscreenElement.webkitRequestFullscreen();\n    } else if (this.fullscreenElement.mozRequestFullscreen) {\n      this.fullscreenElement.mozRequestFullScreen();\n    } else if (this.fullscreenElement.msRequestFullscreen) {\n      this.fullscreenElement.msRequestFullscreen();\n    }\n  }\n\n  requestExitFullscreen() {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    } else if (document.webkitCancelFullScreen) {\n      document.webkitCancelFullScreen();\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen();\n    } else if (document.msExitFullscreen) {\n      document.mozExitFullscreen();\n    }\n  }\n\n  handleFullscreenChange() {\n    const documentFullscreenElement =\n      document.fullscreenElement ||\n      document.webkitFullscreenElement ||\n      document.mozFullScreenElement ||\n      document.msFullscreenElement;\n    this.setState({\n      fullscreen: documentFullscreenElement === this.fullscreenElement\n    });\n  }\n\n  getFullscreenContext() {\n    const fullscreenContext = {\n      fullscreen: this.state.fullscreen,\n      requestFullscreen: this.requestFullscreen,\n      requestExitFullscreen: this.requestExitFullscreen\n    };\n    if (\n      this.fullscreenContext &&\n      fullscreenContext.fullscreen === this.fullscreenContext.fullscreen\n    ) {\n      // no change\n      return this.fullscreenContext;\n    }\n    return (this.fullscreenContext = fullscreenContext);\n  }\n\n  render() {\n    const fullscreenContext = this.getFullscreenContext();\n    return (\n      <div\n        ref={elem => (this.fullscreenElement = elem)}\n        style={this.state.fullscreen ? fullscreenStyle : undefined}\n      >\n        <FullscreenContext.Provider value={fullscreenContext}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(fullscreenContext)\n            : this.props.children}\n        </FullscreenContext.Provider>\n      </div>\n    );\n  }\n}\n\nFullscreenContextProvider.propTypes = {\n  fullscreenEnabled: PropTypes.bool.isRequired,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n};\n\nFullscreenContextProvider.defaultProps = {\n  fullscreenEnabled: true\n};\n\nexport default FullscreenContextProvider;\n","import React, { createElement } from 'react';\n\nimport PlayerContext from './PlayerContext';\nimport FullscreenContext from './FullscreenContext';\nimport { logWarning } from './utils/console';\n\nfunction playerContextFilter(component, contextPropNames) {\n  const warned = {};\n  const childName = component.displayName || component.name;\n  function PlayerContextFilter(props) {\n    return (\n      <FullscreenContext.Consumer>\n        {fullscreenContext => (\n          <PlayerContext.Consumer>\n            {playerContext => {\n              const childProps = { ...props };\n              for (const propName of contextPropNames) {\n                if (playerContext.hasOwnProperty(propName)) {\n                  childProps[propName] = playerContext[propName];\n                } else if (fullscreenContext.hasOwnProperty(propName)) {\n                  childProps[propName] = fullscreenContext[propName];\n                } else if (!warned[propName]) {\n                  logWarning(\n                    \"Prop '\" +\n                      propName +\n                      \"' for component \" +\n                      childName +\n                      ' not found in playerContext or fullscreenContext.'\n                  );\n                  warned[propName] = true;\n                }\n              }\n              return createElement(component, childProps);\n            }}\n          </PlayerContext.Consumer>\n        )}\n      </FullscreenContext.Consumer>\n    );\n  }\n  if (childName) {\n    PlayerContextFilter.displayName = `PlayerContextFilter(${childName})`;\n  }\n  return PlayerContextFilter;\n}\n\nexport default playerContextFilter;\n","import PlayerContextProvider from './PlayerContextProvider';\nimport PlayerContext from './PlayerContext';\nimport PlayerContextGroup from './PlayerContextGroup';\nimport FullscreenContextProvider from './FullscreenContextProvider';\nimport FullscreenContext from './FullscreenContext';\nimport playerContextFilter from './playerContextFilter';\nimport * as PlayerPropTypes from './PlayerPropTypes';\n\nexport { PlayerContextProvider };\nexport const PlayerContextConsumer = PlayerContext.Consumer;\nexport { PlayerContextGroup };\nexport { FullscreenContextProvider };\nexport const FullscreenContextConsumer = FullscreenContext.Consumer;\nexport { playerContextFilter };\nexport { PlayerPropTypes };\n\n// undocumented exports\nexport * from './utils/console';\nexport {\n  default as convertToNumberWithinIntervalBounds\n} from './utils/convertToNumberWithinIntervalBounds';\nexport { default as isPlaylistValid } from './utils/isPlaylistValid';\nexport { repeatStrategyOptions } from './constants';\n"],"sourceRoot":""}